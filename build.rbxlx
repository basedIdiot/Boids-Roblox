<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="10">
		<Properties>
			<float name="AirDensity">0.00120000006</float>
			<bool name="AllowThirdPartySales">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AvatarUnificationMode">0</token>
			<token name="CSGAsyncDynamicCollision">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="ClientAnimatorThrottling">0</token>
			<BinaryString name="CollisionGroupData">AQEABP////8HRGVmYXVsdA==</BinaryString>
			<Ref name="CurrentCamera">RBXA242479A92404BB1A02D8D39B9E35C84</Ref>
			<token name="DecreaseMinimumPartDensityMode">0</token>
			<bool name="DefinesCapabilities">false</bool>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<token name="FluidForces">0</token>
			<Vector3 name="GlobalWind">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<float name="Gravity">196.199997</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="IKControlConstraintSupport">0</token>
			<token name="LevelOfDetail">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<token name="ModelStreamingBehavior">0</token>
			<token name="ModelStreamingMode">0</token>
			<token name="MoverConstraintRootBehavior">0</token>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">false</bool>
			<token name="PathfindingUseImprovedSearch">0</token>
			<token name="PhysicsSteppingMethod">0</token>
			<token name="PlayerCharacterDestroyBehavior">0</token>
			<token name="PrimalPhysicsSolver">0</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="RejectCharacterDeletions">0</token>
			<token name="RenderingCacheOptimizations">0</token>
			<token name="ReplicateInstanceDestroySetting">0</token>
			<token name="Retargeting">0</token>
			<float name="ScaleFactor">1</float>
			<token name="SignalBehavior2">0</token>
			<int64 name="SourceAssetId">-1</int64>
			<token name="StreamOutBehavior">0</token>
			<bool name="StreamingEnabled">false</bool>
			<token name="StreamingIntegrityMode">0</token>
			<int name="StreamingMinRadius">64</int>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e800017f07</UniqueId>
			<OptionalCoordinateFrame name="WorldPivotData">
				<CFrame>
					<X>0</X>
					<Y>-10</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CFrame>
			</OptionalCoordinateFrame>
		</Properties>
		<Item class="Terrain" referent="RBX8B39C03DD1634DCD9DF9935277644019">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">false</bool>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">false</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="GrassLength">0.699999988</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<bool name="ShorelinesUpgraded">true</bool>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<bool name="SmoothVoxelsUpgraded">false</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">0d3aa7196f579588018293e800019222</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBXA3208E4B886C408783050B5A0553C075">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>4.75</X>
					<Y>50.5</Y>
					<Z>5</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">false</bool>
				<bool name="CanQuery">false</bool>
				<bool name="CanTouch">false</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">false</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">BoidTemplate</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">24b5b5913f5c7a6d01f00d7b005cbda6</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Camera" referent="RBXA242479A92404BB1A02D8D39B9E35C84">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>43.0419083</X>
					<Y>10.8234663</Y>
					<Z>7.79120731</Z>
					<R00>-0.763789117</R00>
					<R01>0.518186271</R01>
					<R02>-0.384849548</R02>
					<R10>-0</R10>
					<R11>0.596235335</R11>
					<R12>0.802809715</R12>
					<R20>0.645465851</R20>
					<R21>0.613177299</R21>
					<R22>-0.455398083</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>43.8116074</X>
					<Y>9.21784687</Y>
					<Z>8.70200348</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">6d774d959b01b73807051d29000070b8</UniqueId>
				<bool name="VRTiltAndRollEnabled">false</bool>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX8AA3779D6E574A9C93739E550F02B31E">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Parts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">6d774d959b01b73807051d29000074ee</UniqueId>
			</Properties>
			<Item class="Model" referent="RBX250FCC8C5CC24122A407EC0B2C65F763">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<token name="LevelOfDetail">0</token>
					<CoordinateFrame name="ModelMeshCFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
					<Vector3 name="ModelMeshSize">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="ModelStreamingMode">0</token>
					<string name="Name">box</string>
					<bool name="NeedsPivotMigration">false</bool>
					<Ref name="PrimaryPart">null</Ref>
					<float name="ScaleFactor">1</float>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">6d774d959b01b73807051d29000074ef</UniqueId>
					<OptionalCoordinateFrame name="WorldPivotData">
						<CFrame>
							<X>17.75</X>
							<Y>26.0000114</Y>
							<Z>2.5</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CFrame>
					</OptionalCoordinateFrame>
				</Properties>
				<Item class="Part" referent="RBX3B9DC1EAB2C84A7B8B0D377745A190AF">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>17.75</X>
							<Y>52</Y>
							<Z>17.4227676</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">false</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">Top</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0.5</float>
						<UniqueId name="UniqueId">6d774d959b01b73807051d29000074f0</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>174.5</X>
							<Y>1</Y>
							<Z>111.856689</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX92BCB66BD3DA4061999E9124D84074BD">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>17.75</X>
							<Y>-28.0280056</Y>
							<Z>17.4227638</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">false</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">Bottom</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0.5</float>
						<UniqueId name="UniqueId">6d774d959b01b73807051d29000074f1</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>174.5</X>
							<Y>1</Y>
							<Z>115.856682</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX9103534B4D0A4F2287276EE3CEDD08CC">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>17.7499962</X>
							<Y>12.4860039</Y>
							<Z>74.3511047</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">false</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">Back</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0.5</float>
						<UniqueId name="UniqueId">6d774d959b01b73807051d29000074f2</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>174.5</X>
							<Y>80.0279922</Y>
							<Z>2</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX7B9844188FF14DD6B1DEF8A8A0A57AC4">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>17.75</X>
							<Y>12.4860115</Y>
							<Z>-39.5055771</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">false</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">Front</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0.5</float>
						<UniqueId name="UniqueId">6d774d959b01b73807051d29000074f3</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>174.5</X>
							<Y>80.0280075</Y>
							<Z>2</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX74942023A05E40C993785D29EF702B97">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>106</X>
							<Y>11.9860039</Y>
							<Z>17.4227638</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">false</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">Right</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0.5</float>
						<UniqueId name="UniqueId">6d774d959b01b73807051d29000074f4</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>2</X>
							<Y>81.0280228</Y>
							<Z>115.856682</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBXBE398AB2D2D44706BC43F38AC711DB54">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-70.5</X>
							<Y>11.9860077</Y>
							<Z>17.4227638</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">false</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">Left</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0.5</float>
						<UniqueId name="UniqueId">6d774d959b01b73807051d29000074f5</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>2</X>
							<Y>81.0280304</Y>
							<Z>115.856682</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Part" referent="RBX73BB7DF215954B07A93B70EC8A266693">
					<Properties>
						<bool name="Anchored">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>1.75</X>
							<Y>19.7500114</Y>
							<Z>17.25</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">false</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">Obstacle</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<UniqueId name="UniqueId">6d774d959b01b73807051d29000074f6</UniqueId>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>87.5</X>
							<Y>39.5</Y>
							<Z>14.5</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="SoundService" referent="6">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">true</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e800019173</UniqueId>
			<token name="VolumetricAudio">1</token>
		</Properties>
	</Item>
	<Item class="VideoCaptureService" referent="RBX22E59F1A230745DB98E49BF553C06460">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VideoCaptureService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">42d80392b38072020703dde0000002fe</UniqueId>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBX771DCCA02B9745838B1D7692B9349157">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e80001917f</UniqueId>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBX31AF59ACE8554D2DAB793B415242CFD7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e800019180</UniqueId>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBXC2723E6E513348E1A3ADE4E605F8E3B4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e800019184</UniqueId>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBXC3B62553668440FAB1D89ECD569B7EFB">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e800019185</UniqueId>
		</Properties>
	</Item>
	<Item class="Players" referent="RBXDAE31B48DE86492BA38D56E45B675977">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="CharacterAutoLoads">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxPlayersInternal">12</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">0</int>
			<float name="RespawnTime">5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e800019187</UniqueId>
			<bool name="UseStrafingAnimations">false</bool>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBX258B24BAE4224065A8874D5DF6590737">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e80001918b</UniqueId>
		</Properties>
	</Item>
	<Item class="TweenService" referent="RBXF4D2A94662B14328A52C0FC9D8638AF3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e80001918d</UniqueId>
		</Properties>
	</Item>
	<Item class="MaterialService" referent="RBX3D4A839D20DC4FB19C0C790677ABEDF6">
		<Properties>
			<string name="AsphaltName">Asphalt</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="BasaltName">Basalt</string>
			<string name="BrickName">Brick</string>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<string name="CardboardName">Cardboard</string>
			<string name="CarpetName">Carpet</string>
			<string name="CeramicTilesName">CeramicTiles</string>
			<string name="ClayRoofTilesName">ClayRoofTiles</string>
			<string name="CobblestoneName">Cobblestone</string>
			<string name="ConcreteName">Concrete</string>
			<string name="CorrodedMetalName">CorrodedMetal</string>
			<string name="CrackedLavaName">CrackedLava</string>
			<bool name="DefinesCapabilities">false</bool>
			<string name="DiamondPlateName">DiamondPlate</string>
			<string name="FabricName">Fabric</string>
			<string name="FoilName">Foil</string>
			<string name="GlacierName">Glacier</string>
			<string name="GraniteName">Granite</string>
			<string name="GrassName">Grass</string>
			<string name="GroundName">Ground</string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="IceName">Ice</string>
			<string name="LeafyGrassName">LeafyGrass</string>
			<string name="LeatherName">Leather</string>
			<string name="LimestoneName">Limestone</string>
			<string name="MarbleName">Marble</string>
			<string name="MetalName">Metal</string>
			<string name="MudName">Mud</string>
			<string name="Name">MaterialService</string>
			<string name="PavementName">Pavement</string>
			<string name="PebbleName">Pebble</string>
			<string name="PlasterName">Plaster</string>
			<string name="PlasticName">Plastic</string>
			<string name="RockName">Rock</string>
			<string name="RoofShinglesName">RoofShingles</string>
			<string name="RubberName">Rubber</string>
			<string name="SaltName">Salt</string>
			<string name="SandName">Sand</string>
			<string name="SandstoneName">Sandstone</string>
			<string name="SlateName">Slate</string>
			<string name="SmoothPlasticName">SmoothPlastic</string>
			<string name="SnowName">Snow</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">4f4fc5db8d7f404203b93af5000002d1</UniqueId>
			<bool name="Use2022MaterialsXml">false</bool>
			<string name="WoodName">Wood</string>
			<string name="WoodPlanksName">WoodPlanks</string>
		</Properties>
	</Item>
	<Item class="TextChatService" referent="RBX4256307D6CC54A7EAFB018835D4AE3A3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="ChatTranslationFTUXShown">true</bool>
			<bool name="ChatTranslationToggleEnabled">false</bool>
			<token name="ChatVersion">0</token>
			<bool name="CreateDefaultCommands">true</bool>
			<bool name="CreateDefaultTextChannels">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TextChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">42d80392b38072020703dde00000030f</UniqueId>
		</Properties>
		<Item class="ChatWindowConfiguration" referent="RBXA93E33DEE8534DA59F3C7CA69052DA35">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2999999999999999889</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/Montserrat-Medium.ttf</url></CachedFaceId>
				</Font>
				<float name="HeightScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="HorizontalAlignment">1</token>
				<string name="Name">ChatWindowConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">42d80392b38072020703dde000000367</UniqueId>
				<token name="VerticalAlignment">1</token>
				<float name="WidthScale">1</float>
			</Properties>
		</Item>
		<Item class="ChatInputBarConfiguration" referent="RBX3704746DAD07452E93246E2B1764E5CC">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutocompleteEnabled">true</bool>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2000000000000000111</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/Montserrat-Medium.ttf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="KeyboardKeyCode">47</token>
				<string name="Name">ChatInputBarConfiguration</string>
				<Color3 name="PlaceholderColor3">
					<R>0.698039234</R>
					<G>0.698039234</G>
					<B>0.698039234</B>
				</Color3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Ref name="TargetTextChannel">null</Ref>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">42d80392b38072020703dde000000368</UniqueId>
			</Properties>
		</Item>
		<Item class="BubbleChatConfiguration" referent="RBX1F597C59A82049FAB9344DBDDD6D794A">
			<Properties>
				<string name="AdorneeName">HumanoidRootPart</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.980392158</R>
					<G>0.980392158</G>
					<B>0.980392158</B>
				</Color3>
				<double name="BackgroundTransparency">0.10000000000000000555</double>
				<float name="BubbleDuration">15</float>
				<float name="BubblesSpacing">6</float>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<token name="Font">18</token>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/Montserrat-Medium.ttf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Vector3 name="LocalPlayerStudsOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="MaxBubbles">3</float>
				<float name="MaxDistance">100</float>
				<float name="MinimizeDistance">40</float>
				<string name="Name">BubbleChatConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<bool name="TailVisible">true</bool>
				<Color3 name="TextColor3">
					<R>0.223529413</R>
					<G>0.23137255</G>
					<B>0.239215687</B>
				</Color3>
				<int64 name="TextSize">16</int64>
				<UniqueId name="UniqueId">42d80392b38072020703dde000000369</UniqueId>
				<float name="VerticalStudsOffset">0</float>
			</Properties>
		</Item>
	</Item>
	<Item class="PermissionsService" referent="RBX9F5224105AAD46689B9F8A18AB9D8433">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e800019191</UniqueId>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBXC81FC990AD4749C4ABE1672AC49C5358">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="CustomPoliciesEnabled">false</bool>
			<bool name="DefinesCapabilities">false</bool>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<bool name="PseudolocalizationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e800019193</UniqueId>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBX0E91094E211E4AD7A04DF533F3DDC1BD">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e800019195</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="7">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<token name="AvatarJointUpgrade_Serialized">0</token>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<bool name="DefinesCapabilities">false</bool>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<token name="EnableDynamicHeads">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadCharacterAppearance">false</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<token name="LuaCharacterController">0</token>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e800019196</UniqueId>
			<bool name="UserEmotesEnabled">false</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="8">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">0d3aa7196f579588018293e800019366</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBX803F8F4059F44AB7A7F68654FE28605F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Boids</string>
					<string name="ScriptGuid">{D650D4A5-9090-4588-BF0C-44106E883148}</string>
					<ProtectedString name="Source">return require(script.Packages[&quot;Boids&quot;])</ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">6aa5ca279eda671204c67b5600003d16</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBXEC3D1ABC154846168E3FBDBB51F2159D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Packages</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">6aa5ca279eda671204c67b5600003d17</UniqueId>
					</Properties>
					<Item class="Folder" referent="RBX07A7B35545444B82AA4AD7E51B2C2E9F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">_Index</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6aa5ca279eda671204c67b5600003d18</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBX8923AA2E4CB847709BFAE1D37A5CB3DA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">howmanysmall_janitor@1.15.3</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">6aa5ca279eda671204c67b5600003d19</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX21DFC659FF9C43BCB8CCCA9E8613051E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">janitor</string>
									<string name="ScriptGuid">{5014F13C-16C3-44B6-90D2-62667405FE77}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with L+ C Edition
-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark
-- LinkToInstance fixed by Elttob.
-- Cleanup edge cases fixed by codesenseAye.

local GetPromiseLibrary = require(script.GetPromiseLibrary)
local RbxScriptConnection = require(script.RbxScriptConnection)
local Symbol = require(script.Symbol)
local FoundPromiseLibrary, Promise = GetPromiseLibrary()

local IndicesReference = Symbol("IndicesReference")
local LinkToInstanceIndex = Symbol("LinkToInstanceIndex")

local INVALID_METHOD_NAME = "Object is a %s and as such expected `true?` for the method name and instead got %s. Traceback: %s"
local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s)) Traceback: %s"

type RbxScriptConnection = RbxScriptConnection.RbxScriptConnection

--[=[
	Janitor is a light-weight, flexible object for cleaning up connections, instances, or anything. This implementation covers all use cases,
	as it doesn't force you to rely on naive typechecking to guess how an instance should be cleaned up.
	Instead, the developer may specify any behavior for any object.

	@class Janitor
]=]
local Janitor = {}
Janitor.ClassName = "Janitor"
Janitor.CurrentlyCleaning = true
Janitor[IndicesReference] = nil
Janitor.__index = Janitor

--[=[
	@prop CurrentlyCleaning boolean
	@within Janitor

	Whether or not the Janitor is currently cleaning up.
]=]

local TypeDefaults = {
	["function"] = true;
	thread = true;
	RBXScriptConnection = "Disconnect";
}

--[=[
	Instantiates a new Janitor object.
	@return Janitor
]=]
function Janitor.new(): Janitor
	return setmetatable({
		CurrentlyCleaning = false;
		[IndicesReference] = nil;
	}, Janitor) :: any
end

--[=[
	Determines if the passed object is a Janitor. This checks the metatable directly.

	@param Object any -- The object you are checking.
	@return boolean -- `true` if `Object` is a Janitor.
]=]
function Janitor.Is(Object: any): boolean
	return type(Object) == "table" and getmetatable(Object) == Janitor
end

type BooleanOrString = boolean | string

--[=[
	Adds an `Object` to Janitor for later cleanup, where `MethodName` is the key of the method within `Object` which should be called at cleanup time.
	If the `MethodName` is `true` the `Object` itself will be called if it's a function or have `task.cancel` called on it if it is a thread. If passed
	an index it will occupy a namespace which can be `Remove()`d or overwritten. Returns the `Object`.

	:::info
	Objects not given an explicit `MethodName` will be passed into the `typeof` function for a very naive typecheck.
	RBXConnections will be assigned to "Disconnect", functions and threads will be assigned to `true`, and everything else will default to "Destroy".
	Not recommended, but hey, you do you.
	:::

	### Luau:

	```lua
	local Workspace = game:GetService("Workspace")
	local TweenService = game:GetService("TweenService")

	local Obliterator = Janitor.new()
	local Part = Workspace.Part

	-- Queue the Part to be Destroyed at Cleanup time
	Obliterator:Add(Part, "Destroy")

	-- Queue function to be called with `true` MethodName
	Obliterator:Add(print, true)

	-- Close a thread.
	Obliterator:Add(task.defer(function()
		while true do
			print("Running!")
			task.wait(0.5)
		end
	end), true)

	-- This implementation allows you to specify behavior for any object
	Obliterator:Add(TweenService:Create(Part, TweenInfo.new(1), {Size = Vector3.new(1, 1, 1)}), "Cancel")

	-- By passing an Index, the Object will occupy a namespace
	-- If "CurrentTween" already exists, it will call :Remove("CurrentTween") before writing
	Obliterator:Add(TweenService:Create(Part, TweenInfo.new(1), {Size = Vector3.new(1, 1, 1)}), "Destroy", "CurrentTween")
	```

	### TypeScript:

	```ts
	import { Workspace, TweenService } from "@rbxts/services";
	import { Janitor } from "@rbxts/janitor";

	const Obliterator = new Janitor<{ CurrentTween: Tween }>();
	const Part = Workspace.FindFirstChild("Part") as Part;

	// Queue the Part to be Destroyed at Cleanup time
	Obliterator.Add(Part, "Destroy");

	// Queue function to be called with `true` MethodName
	Obliterator.Add(print, true);

	// Close a thread.
	Obliterator.Add(task.defer(() => {
		while (true) {
			print("Running!");
			task.wait(0.5);
		}
	}), true);

	// This implementation allows you to specify behavior for any object
	Obliterator.Add(TweenService.Create(Part, new TweenInfo(1), {Size: new Vector3(1, 1, 1)}), "Cancel");

	// By passing an Index, the Object will occupy a namespace
	// If "CurrentTween" already exists, it will call :Remove("CurrentTween") before writing
	Obliterator.Add(TweenService.Create(Part, new TweenInfo(1), {Size: new Vector3(1, 1, 1)}), "Destroy", "CurrentTween");
	```

	@param Object T -- The object you want to clean up.
	@param MethodName? string|true -- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes `Destroy`.
	@param Index? any -- The index that can be used to clean up the object manually.
	@return T -- The object that was passed as the first argument.
]=]
function Janitor:Add<T>(Object: T, MethodName: BooleanOrString?, Index: any?): T
	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]
		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end

	local TypeOf = typeof(Object)
	local NewMethodName = MethodName or TypeDefaults[TypeOf] or "Destroy"

	if TypeOf == "function" or TypeOf == "thread" then
		if NewMethodName ~= true then
			warn(string.format(INVALID_METHOD_NAME, TypeOf, tostring(NewMethodName), debug.traceback(nil :: any, 2)))
		end
	else
		if not (Object :: any)[NewMethodName] then
			warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(NewMethodName), debug.traceback(nil :: any, 2)))
		end
	end

	self[Object] = NewMethodName
	return Object
end

--[=[
	Adds a [Promise](https://github.com/evaera/roblox-lua-promise) to the Janitor. If the Janitor is cleaned up and the Promise is not completed, the Promise will be cancelled.

	### Luau:

	```lua
	local Obliterator = Janitor.new()
	Obliterator:AddPromise(Promise.delay(3)):andThenCall(print, "Finished!"):catch(warn)
	task.wait(1)
	Obliterator:Cleanup()
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	const Obliterator = new Janitor();
	Obliterator.AddPromise(Promise.delay(3)).andThenCall(print, "Finished!").catch(warn);
	task.wait(1);
	Obliterator.Cleanup();
	```

	@param PromiseObject Promise -- The promise you want to add to the Janitor.
	@return Promise
]=]
function Janitor:AddPromise(PromiseObject)
	if FoundPromiseLibrary then
		if not Promise.is(PromiseObject) then
			error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject), debug.traceback(nil :: any, 2)))
		end

		if PromiseObject:getStatus() == Promise.Status.Started then
			local Id = newproxy(false)
			local NewPromise = self:Add(Promise.new(function(Resolve, _, OnCancel)
				if OnCancel(function()
					PromiseObject:cancel()
				end) then
					return
				end

				Resolve(PromiseObject)
			end), "cancel", Id)

			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise
		else
			return PromiseObject
		end
	else
		return PromiseObject
	end
end

--[=[
	Cleans up whatever `Object` was set to this namespace by the 3rd parameter of [Janitor.Add](#Add).

	### Luau:

	```lua
	local Obliterator = Janitor.new()
	Obliterator:Add(workspace.Baseplate, "Destroy", "Baseplate")
	Obliterator:Remove("Baseplate")
	```

	### TypeScript:

	```ts
	import { Workspace } from "@rbxts/services";
	import { Janitor } from "@rbxts/janitor";

	const Obliterator = new Janitor<{ Baseplate: Part }>();
	Obliterator.Add(Workspace.FindFirstChild("Baseplate") as Part, "Destroy", "Baseplate");
	Obliterator.Remove("Baseplate");
	```

	@param Index any -- The index you want to remove.
	@return Janitor
]=]
function Janitor:Remove(Index: any)
	local This = self[IndicesReference]

	if This then
		local Object = This[Index]

		if Object then
			local MethodName = self[Object]

			if MethodName then
				if MethodName == true then
					if type(Object) == "function" then
						Object()
					else
						local Cancelled
						if coroutine.running() ~= Object then
							Cancelled = pcall(function()
								task.cancel(Object)
							end)
						end

						if not Cancelled then
							task.defer(function()
								task.cancel(Object)
							end)
						end
					end
				else
					local ObjectMethod = Object[MethodName]
					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end

--[=[
	Removes an object from the Janitor without running a cleanup.

	### Luau

	```lua
	local Obliterator = Janitor.new()
	Obliterator:Add(function()
		print("Removed!")
	end, true, "Function")

	Obliterator:RemoveNoClean("Function") -- Does not print.
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	const Obliterator = new Janitor<{ Function: () => void }>();
	Obliterator.Add(() => print("Removed!"), true, "Function");

	Obliterator.RemoveNoClean("Function"); // Does not print.
	```

	@since v1.15
	@param Index any -- The index you are removing.
	@return Janitor
]=]
function Janitor:RemoveNoClean(Index: any)
	local This = self[IndicesReference]

	if This then
		local Object = This[Index]
		if Object then
			self[Object] = nil
		end

		This[Index] = nil
	end

	return self
end

--[=[
	Cleans up multiple objects at once.

	### Luau:

	```lua
	local Obliterator = Janitor.new()
	Obliterator:Add(function()
		print("Removed One")
	end, true, "One")

	Obliterator:Add(function()
		print("Removed Two")
	end, true, "Two")

	Obliterator:Add(function()
		print("Removed Three")
	end, true, "Three")

	Obliterator:RemoveList("One", "Two", "Three") -- Prints "Removed One", "Removed Two", and "Removed Three"
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	type NoOp = () => void

	const Obliterator = new Janitor<{ One: NoOp, Two: NoOp, Three: NoOp }>();
	Obliterator.Add(() => print("Removed One"), true, "One");
	Obliterator.Add(() => print("Removed Two"), true, "Two");
	Obliterator.Add(() => print("Removed Three"), true, "Three");

	Obliterator.RemoveList("One", "Two", "Three"); // Prints "Removed One", "Removed Two", and "Removed Three"
	```

	@since v1.14
	@param ... any -- The indices you want to remove.
	@return Janitor
]=]
function Janitor:RemoveList(...: any)
	local This = self[IndicesReference]
	if This then
		local Length = select("#", ...)
		if Length == 1 then
			return self:Remove(...)
		else
			for SelectIndex = 1, Length do
				-- MACRO
				local Index = select(SelectIndex, ...)
				local Object = This[Index]
				if Object then
					local MethodName = self[Object]

					if MethodName then
						if MethodName == true then
							if type(Object) == "function" then
								Object()
							else
								local Cancelled
								if coroutine.running() ~= Object then
									Cancelled = pcall(function()
										task.cancel(Object)
									end)
								end

								if not Cancelled then
									task.defer(function()
										task.cancel(Object)
									end)
								end
							end
						else
							local ObjectMethod = Object[MethodName]
							if ObjectMethod then
								ObjectMethod(Object)
							end
						end

						self[Object] = nil
					end

					This[Index] = nil
				end
			end
		end
	end

	return self
end

--[=[
	Cleans up multiple objects at once without running their cleanup.

	### Luau:

	```lua
	local Obliterator = Janitor.new()
	Obliterator:Add(function()
		print("Removed One")
	end, true, "One")

	Obliterator:Add(function()
		print("Removed Two")
	end, true, "Two")

	Obliterator:Add(function()
		print("Removed Three")
	end, true, "Three")

	Obliterator:RemoveListNoClean("One", "Two", "Three") -- Nothing is printed.
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	type NoOp = () => void

	const Obliterator = new Janitor<{ One: NoOp, Two: NoOp, Three: NoOp }>();
	Obliterator.Add(() => print("Removed One"), true, "One");
	Obliterator.Add(() => print("Removed Two"), true, "Two");
	Obliterator.Add(() => print("Removed Three"), true, "Three");

	Obliterator.RemoveListNoClean("One", "Two", "Three"); // Nothing is printed.
	```

	@since v1.15
	@param ... any -- The indices you want to remove.
	@return Janitor
]=]
function Janitor:RemoveListNoClean(...: any)
	local This = self[IndicesReference]
	if This then
		local Length = select("#", ...)
		if Length == 1 then
			return self:RemoveNoClean(...)
		else
			for SelectIndex = 1, Length do
				-- MACRO
				local Index = select(SelectIndex, ...)
				local Object = This[Index]
				if Object then
					self[Object] = nil
				end

				This[Index] = nil
			end
		end
	end

	return self
end

--[=[
	Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the task using `__index`.

	### Luau:

	```lua
	local Obliterator = Janitor.new()
	Obliterator:Add(workspace.Baseplate, "Destroy", "Baseplate")
	print(Obliterator:Get("Baseplate")) -- Returns Baseplate.
	```

	### TypeScript:

	```ts
	import { Workspace } from "@rbxts/services";
	import { Janitor } from "@rbxts/janitor";

	const Obliterator = new Janitor<{ Baseplate: Part }>();
	Obliterator.Add(Workspace.FindFirstChild("Baseplate") as Part, "Destroy", "Baseplate");
	print(Obliterator.Get("Baseplate")); // Returns Baseplate.
	```

	@param Index any -- The index that the object is stored under.
	@return any? -- This will return the object if it is found, but it won't return anything if it doesn't exist.
]=]
function Janitor:Get(Index: any): any?
	local This = self[IndicesReference]
	return if This then This[Index] else nil
end

--[=[
	Returns a frozen copy of the Janitor's indices.

	### Luau:

	```lua
	local Obliterator = Janitor.new()
	Obliterator:Add(workspace.Baseplate, "Destroy", "Baseplate")
	print(Obliterator:GetAll().Baseplate) -- Prints Baseplate.
	```

	### TypeScript:

	```ts
	import { Workspace } from "@rbxts/services";
	import { Janitor } from "@rbxts/janitor";

	const Obliterator = new Janitor<{ Baseplate: Part }>();
	Obliterator.Add(Workspace.FindFirstChild("Baseplate") as Part, "Destroy", "Baseplate");
	print(Obliterator.GetAll().Baseplate); // Prints Baseplate.
	```

	@since v1.15.1
	@return {[any]: any}
]=]
function Janitor:GetAll(): {[any]: any}
	local This = self[IndicesReference]
	return if This then table.freeze(table.clone(This)) else {}
end

local function GetFenv(self)
	return function()
		for Object, MethodName in next, self do
			if Object ~= IndicesReference then
				return Object, MethodName
			end
		end
	end
end

--[=[
	Calls each Object's `MethodName` (or calls the Object if `MethodName == true`) and removes them from the Janitor. Also clears the namespace.
	This function is also called when you call a Janitor Object (so it can be used as a destructor callback).

	### Luau:

	```lua
	Obliterator:Cleanup() -- Valid.
	Obliterator() -- Also valid.
	```

	### TypeScript:

	```ts
	Obliterator.Cleanup()
	```
]=]
function Janitor:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil

		local Get = GetFenv(self)
		local Object, MethodName = Get()

		while Object and MethodName do -- changed to a while loop so that if you add to the janitor inside of a callback it doesn't get untracked (instead it will loop continuously which is a lot better than a hard to pindown edgecase)
			if MethodName == true then
				if type(Object) == "function" then
					Object()
				else
					local Cancelled
					if coroutine.running() ~= Object then
						Cancelled = pcall(function()
							task.cancel(Object)
						end)
					end

					if not Cancelled then
						task.defer(function()
							task.cancel(Object)
						end)
					end
				end
			else
				local ObjectMethod = Object[MethodName]
				if ObjectMethod then
					ObjectMethod(Object)
				end
			end

			self[Object] = nil
			Object, MethodName = Get()
		end

		local This = self[IndicesReference]
		if This then
			table.clear(This)
			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end

--[=[
	Calls [Janitor.Cleanup](#Cleanup) and renders the Janitor unusable.

	:::warning
	Running this will make any further attempts to call a method of Janitor error.
	:::
]=]
function Janitor:Destroy()
	self:Cleanup()
	table.clear(self)
	setmetatable(self, nil)
end

Janitor.__call = Janitor.Cleanup

--[=[
	"Links" this Janitor to an Instance, such that the Janitor will `Cleanup` when the Instance is `Destroyed()` and garbage collected.
	A Janitor may only be linked to one instance at a time, unless `AllowMultiple` is true. When called with a truthy `AllowMultiple` parameter,
	the Janitor will "link" the Instance without overwriting any previous links, and will also not be overwritable.
	When called with a falsy `AllowMultiple` parameter, the Janitor will overwrite the previous link which was also called with a falsy `AllowMultiple` parameter, if applicable.

	### Luau:

	```lua
	local Obliterator = Janitor.new()

	Obliterator:Add(function()
		print("Cleaning up!")
	end, true)

	do
		local Folder = Instance.new("Folder")
		Obliterator:LinkToInstance(Folder)
		Folder:Destroy()
	end
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	const Obliterator = new Janitor();
	Obliterator.Add(() => print("Cleaning up!"), true);

	{
		const Folder = new Instance("Folder");
		Obliterator.LinkToInstance(Folder, false);
		Folder.Destroy();
	}
	```

	@param Object Instance -- The instance you want to link the Janitor to.
	@param AllowMultiple? boolean -- Whether or not to allow multiple links on the same Janitor.
	@return RBXScriptConnection -- A RBXScriptConnection that can be disconnected to prevent the cleanup of LinkToInstance.
]=]
function Janitor:LinkToInstance(Object: Instance, AllowMultiple: boolean?): RBXScriptConnection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex

	return self:Add(Object.Destroying:Connect(function()
		self:Cleanup()
	end), "Disconnect", IndexToUse)
end

--[=[
	This is the legacy LinkToInstance function. It is kept for backwards compatibility in case something is different with `Instance.Destroying`.

	"Links" this Janitor to an Instance, such that the Janitor will `Cleanup` when the Instance is `Destroyed()` and garbage collected.
	A Janitor may only be linked to one instance at a time, unless `AllowMultiple` is true. When called with a truthy `AllowMultiple` parameter,
	the Janitor will "link" the Instance without overwriting any previous links, and will also not be overwritable.
	When called with a falsy `AllowMultiple` parameter, the Janitor will overwrite the previous link which was also called with a falsy `AllowMultiple` parameter, if applicable.
	This returns a mock `RBXScriptConnection` (see: [RbxScriptConnection](/api/RbxScriptConnection)).

	### Luau:

	```lua
	local Obliterator = Janitor.new()

	Obliterator:Add(function()
		print("Cleaning up!")
	end, true)

	do
		local Folder = Instance.new("Folder")
		Obliterator:LinkToInstance(Folder)
		Folder:Destroy()
	end
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	const Obliterator = new Janitor();
	Obliterator.Add(() => print("Cleaning up!"), true);

	{
		const Folder = new Instance("Folder");
		Obliterator.LinkToInstance(Folder, false);
		Folder.Destroy();
	}
	```

	@deprecated v1.4.1 -- Use `Janitor:LinkToInstance` instead.
	@param Object Instance -- The instance you want to link the Janitor to.
	@param AllowMultiple? boolean -- Whether or not to allow multiple links on the same Janitor.
	@return RbxScriptConnection -- A pseudo RBXScriptConnection that can be disconnected to prevent the cleanup of LinkToInstance.
]=]
function Janitor:LegacyLinkToInstance(Object: Instance, AllowMultiple: boolean?): RbxScriptConnection
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, RbxScriptConnection)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				task.defer(function()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							task.wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil :: any
	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end

--[=[
	Links several instances to a new Janitor, which is then returned.

	@param ... Instance -- All the Instances you want linked.
	@return Janitor -- A new Janitor that can be used to manually disconnect all LinkToInstances.
]=]
function Janitor:LinkToInstances(...: Instance)
	local ManualCleanup = Janitor.new()
	for _, Object in {...} do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end

function Janitor:__tostring()
	return "Janitor"
end

export type Janitor = {
	ClassName: "Janitor",
	CurrentlyCleaning: boolean,

	Add: <T>(self: Janitor, Object: T, MethodName: BooleanOrString?, Index: any?) -> T,
	AddPromise: <T>(self: Janitor, PromiseObject: T) -> T,

	Remove: (self: Janitor, Index: any) -> Janitor,
	RemoveNoClean: (self: Janitor, Index: any) -> Janitor,

	RemoveList: (self: Janitor, ...any) -> Janitor,
	RemoveListNoClean: (self: Janitor, ...any) -> Janitor,

	Get: (self: Janitor, Index: any) -> any?,
	GetAll: (self: Janitor) -> {[any]: any},

	Cleanup: (self: Janitor) -> (),
	Destroy: (self: Janitor) -> (),

	LinkToInstance: (self: Janitor, Object: Instance, AllowMultiple: boolean?) -> RBXScriptConnection,
	LegacyLinkToInstance: (self: Janitor, Object: Instance, AllowMultiple: boolean?) -> RbxScriptConnection,

	LinkToInstances: (self: Janitor, ...Instance) -> Janitor,
}

table.freeze(Janitor)
return Janitor
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">6aa5ca279eda671204c67b5600003d1a</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXBC533BC0BDCD43B7892B082CEC92BA73">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">GetPromiseLibrary</string>
										<string name="ScriptGuid">{9CA0FC66-4122-45D3-927F-B1FEC398D683}</string>
										<ProtectedString name="Source"><![CDATA[-- TODO: When Promise is on Wally, remove this in favor of just `script.Parent.Parent:FindFirstChild("Promise")`.
local ReplicatedFirst = game:GetService("ReplicatedFirst")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local ServerStorage = game:GetService("ServerStorage")

local LOCATIONS_TO_SEARCH = {script.Parent.Parent, ReplicatedFirst, ReplicatedStorage, ServerScriptService, ServerStorage}

local function FindFirstDescendantWithNameAndClassName(Parent: Instance, Name: string, ClassName: string)
	for _, Descendant in ipairs(Parent:GetDescendants()) do
		if Descendant:IsA(ClassName) and Descendant.Name == Name then
			return Descendant
		end
	end

	return nil
end

local function GetPromiseLibrary()
	-- I'm not too keen on how this is done.
	-- It's better than the multiple if statements (probably).
	local Plugin = script:FindFirstAncestorOfClass("Plugin")
	if Plugin then
		local Promise = FindFirstDescendantWithNameAndClassName(Plugin, "Promise", "ModuleScript")
		if Promise then
			return true, require(Promise)
		else
			return false
		end
	end

	local Promise
	for _, Location in ipairs(LOCATIONS_TO_SEARCH) do
		Promise = FindFirstDescendantWithNameAndClassName(Location, "Promise", "ModuleScript")
		if Promise then
			break
		end
	end

	if Promise then
		return true, require(Promise)
	else
		return false
	end
end

return GetPromiseLibrary
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6aa5ca279eda671204c67b5600003d1b</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX9D9C6FC5E6DA46A292B3FB5C2964677B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">RbxScriptConnection</string>
										<string name="ScriptGuid">{F6CEA293-E324-4286-973F-B2ABB8C59F53}</string>
										<ProtectedString name="Source"><![CDATA[--[=[
	A wrapper for an `RBXScriptConnection`. Makes the Janitor clean up when the instance is destroyed. This was created by Corecii.

	@class RbxScriptConnection
]=]
local RbxScriptConnection = {}
RbxScriptConnection.Connected = true
RbxScriptConnection.__index = RbxScriptConnection

--[=[
	@prop Connected boolean
	@within RbxScriptConnection

	Whether or not this connection is still connected.
]=]

--[=[
	Disconnects the Signal.
]=]
function RbxScriptConnection:Disconnect()
	if self.Connected then
		self.Connected = false
		self.Connection:Disconnect()
	end
end

function RbxScriptConnection._new(RBXScriptConnection: RBXScriptConnection)
	return setmetatable({
		Connection = RBXScriptConnection;
	}, RbxScriptConnection)
end

function RbxScriptConnection:__tostring()
	return "RbxScriptConnection<" .. tostring(self.Connected) .. ">"
end

export type RbxScriptConnection = typeof(RbxScriptConnection._new(game:GetPropertyChangedSignal("ClassName"):Connect(function() end)))
return RbxScriptConnection
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6aa5ca279eda671204c67b5600003d1c</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXB0A4C5F1E76941E180E1451118FB3434">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Symbol</string>
										<string name="ScriptGuid">{EC40A3CB-9D6F-425B-B736-563BC40DB66A}</string>
										<ProtectedString name="Source"><![CDATA[-- This only exists because the LSP warns Key `__tostring` not found in type `table?`.
local function Symbol(Name: string)
	local self = newproxy(true)
	local Metatable = getmetatable(self)
	function Metatable.__tostring()
		return Name
	end

	return self
end

return Symbol
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6aa5ca279eda671204c67b5600003d1d</UniqueId>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX4842BCBAFD464874B80755DF20C6D097">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">janitor</string>
							<string name="ScriptGuid">{1CF7BD7F-CBB4-4F05-B6CC-902AFD7D979E}</string>
							<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["howmanysmall_janitor@1.15.3"]["janitor"])
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6aa5ca279eda671204c67b5600003d1e</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX48B21E43C67043FCBF9136ABB190CB10">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Boids</string>
							<string name="ScriptGuid">{66C5EA1F-7382-486D-94EF-7A3319A28CF6}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
local Boid = {}
Boid.Interface = {}
Boid.Schema = {}
Boid.Metatable = { __index = Boid.Schema }
Boid.__index = {}

local Janitor = require(script.Parent.janitor)

local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local SharedTableRegistry = game:GetService("SharedTableRegistry")

local AutoUpdate = false -- determines whether the script will automatically update the boids position each frame
-- Good for benchmarking certain functions

local NUM_ACTORS = 16

local MIN_SPEED = 2
local MAX_SPEED = 10
local MAX_ACCELERATION = 20

local RANGE = 10
local VIEW_ANGLE = math.pi -- measured in radians
local AVOID_RADIUS = 2

local PHI = 1.618033988749
local ANGLE_INCREMENT = 2 * math.pi * PHI
local NUM_VIEW_DIRECTIONS = 100
local OBSTACLE_AVOID_RADIUS = 30
local OBSTACLE_MARGIN = 1
local DEFAULT_RAYCAST_PARAMS = RaycastParams.new()

local SEPERATION_WEIGHT = 10
local ALIGN_WEIGHT = 1
local COHESIVE_WEIGHT = 1
local OBSTACLE_AVOID_WEIGHT = 20
local TARGET_WEIGHT = 1


local BoidArray = {}
Boid.BoidArray = BoidArray
local SharedBoidTable = SharedTable.new()
local BoidIdMap = {}
SharedTableRegistry:SetSharedTable("BoidTable", SharedBoidTable)

local ActorArray = {}
local CurrentActor = 0
for i = 1, NUM_ACTORS do
	local NewActor
	if RunService:IsClient() then
		NewActor = script.BoidActor:Clone()
	else
		NewActor = script.BoidActorServer:Clone()
	end
	NewActor.BoidActorScript.Enabled = true
	NewActor.Parent = script
	ActorArray[i] = NewActor
end

local BoidFolder = Instance.new("Folder")
BoidFolder.Name = "Boids"
BoidFolder.Parent = workspace

export type Boid = typeof(Boid.Interface.new(table.unpack(...)))--[[{
	Model: BasePart | Model,

	Position: Vector3,
	Velocity: Vector3,
	Acceleration: Vector3,

	Range: number,
	ViewAngle: number,
	AvoidRadius: number,

	MinSpeed: number,
	MaxSpeed: number,
	MaxAcceleration: number,

	Target: Vector3?,

	Id: number,
}]]
local function ComputeSphereVectors(Length: number?): { [number]: Vector3 }
	local Directions = table.create(NUM_VIEW_DIRECTIONS)
	Length = Length or 1

	for I = 1, NUM_VIEW_DIRECTIONS do
		local T = I / NUM_VIEW_DIRECTIONS
		local Inclination = math.acos(1 - 2 * T)
		local Azimuth = ANGLE_INCREMENT * I

		local X = math.sin(Inclination) * math.cos(Azimuth)
		local Y = math.sin(Inclination) * math.sin(Azimuth)
		local Z = math.cos(Inclination)
		Directions[I] = Vector3.new(X, Y, Z) * Length
	end
	return Directions
end
function Boid.Interface.GetBoids(): { [number]: Boid }
	return table.clone(BoidArray)
end
function Boid.Interface.GetBoidFromId(BoidId): Boid?
	return BoidIdMap[BoidId]
end

function Boid.Interface.Pause()
	AutoUpdate = false
	for _, Actor in ActorArray do
		Actor:SendMessage("Pause")
	end
end
function Boid.Interface.Unpause()
	AutoUpdate = true
	for _, Actor in ActorArray do
		Actor:SendMessage("Unpause")
	end
end
function Boid.Interface.new(
	Model: BasePart | Model,
	Position: Vector3?,
	Velocity: Vector3?,
	Range: number?,
	ViewAngle: number?
): Boid
	local NewModel = Model:Clone()
	NewModel:PivotTo(CFrame.lookAt(Position, Position + Velocity))
	NewModel.Parent = BoidFolder

	local Id = HttpService:GenerateGUID()
	-- Have to be comically unlucky for while loop to happen
	while BoidIdMap[Id] do
		Id = HttpService:GenerateGUID()
	end
	local self = {
		Model = NewModel,

		Position = Position or Vector3.zero,
		Velocity = Velocity or Vector3.one,
		Acceleration = Vector3.one,

		Range = Range or RANGE,
		ViewAngle = ViewAngle or VIEW_ANGLE,
		AvoidRadius = AVOID_RADIUS,

		IsObstacleAvoidanceEnabled = true,
		ObstacleAvoidRadius = OBSTACLE_AVOID_RADIUS,
		ObstacleParams = DEFAULT_RAYCAST_PARAMS,
		ObstacleMargin = OBSTACLE_MARGIN,

		MinSpeed = MIN_SPEED,
		MaxSpeed = MAX_SPEED,
		MaxAcceleration = MAX_ACCELERATION,

		Target = nil,

		SeparationWeight = SEPERATION_WEIGHT,
		AlignWeight = ALIGN_WEIGHT,
		CohesiveWeight = COHESIVE_WEIGHT,
		ObstacleAvoidWeight = OBSTACLE_AVOID_WEIGHT,
		TargetWeight = TARGET_WEIGHT,

		Id = Id,

		__LastVelocityUpdateTime = os.clock(),

		__Directions = ComputeSphereVectors(OBSTACLE_AVOID_RADIUS),
		__Janitor = Janitor.new(),
		__Actor = ActorArray[CurrentActor + 1]
	}
	self.__Actor:SendMessage("NewBoid", self)
	CurrentActor = (CurrentActor + 1) % NUM_ACTORS
	if self.Model then
		self.__Janitor:Add(Model, "Destroy")
	end
	table.insert(BoidArray, self)
	BoidIdMap[Id] = self
	SharedBoidTable[Id] = {
		Id = self.Id,
		Position = self.Position,
		Velocity = self.Velocity
	}
	return setmetatable(self, Boid.Metatable)
end
function Boid.Schema:Destroy()
	self.__Actor:SendMessage("DestroyBoid", self.Id)
	self.__Janitor:Destroy()
	table.remove(BoidIdMap, self.Id)
	table.remove(BoidArray, table.find(BoidArray, self))
end
function Boid.Schema:GetDirection(): Vector3
	return self.Velocity.Unit
end
function Boid.Schema:SetPosition(Position: Vector3)
	self.Position = Position
	self.Model:PivotTo(CFrame.lookAt(Position, Position + self.Velocity))
	self.__Actor:SendMessage("UpdateBoid", self.Id, "Position", Position)
end
function Boid.Schema:SetVelocity(Velocity: Vector3)
	self.Velocity = Velocity
	self.Model:PivotTo(CFrame.lookAt(self.Position, self.Position + Velocity))
	self.__Actor:SendMessage("UpdateBoid", self.Id, "Velocity", Velocity)
end
function Boid.Schema:SetObstacleAvoidRadius(Radius: number)
	self.ObstacleAvoidRadius = Radius
	self.__Directions = ComputeSphereVectors(Radius)
	self.__Actor:SendMessage("UpdateBoid", self.Id, "ObstacleAvoidRadius", Radius)
end
function Boid.Schema:Set(Property: string, input)
	if Property == "Position" then
		self:SetPosition(input)
		return
	end
	if Property == "Velocity" then
		self:SetVelocity(input)
		return
	end
	if Property == "ObstacleAvoidRadius" then
		self:SetObstacleAvoidRadius(input)
		return
	end
	self[Property] = input
	self.__Actor:SendMessage("UpdateBoid", self.Id, Property, input)
end
-- Position update --
RunService.Heartbeat:Connect(function(DeltaTime)
	if not AutoUpdate then
		return
	end
	local PartTable = table.create(#BoidArray)
	local PositionTable = table.create(#BoidArray)
	for _, Boid in ipairs(BoidArray) do
		if Boid.Model:IsA("BasePart") then
			table.insert(PartTable, Boid.Model)
			table.insert(PositionTable, CFrame.new(Boid.Position, Boid.Position + Boid.Velocity))
		else
			Boid.Model:PivotTo(CFrame.new(Boid.Position, Boid.Position + Boid.Velocity))
		end
	end
	workspace:BulkMoveTo(PartTable, PositionTable, Enum.BulkMoveMode.FireCFrameChanged)
end)
-- Velocity update --
-- Seperated from position update due to possible differing update frequencies
script.BoidDone.Event:Connect(function (BoidId, Position, Velocity, Acceleration)
	local Boid = Boid.Interface.GetBoidFromId(BoidId)
	Boid.Position = Position
	Boid.Velocity = Velocity
	Boid.Acceleration = Acceleration
end)

return Boid.Interface
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6aa5ca279eda671204c67b5600003da1</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX7B3A3CCD4DB141F081196051CFA2372A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">CeiveImGizmo</string>
								<string name="ScriptGuid">{4DA07181-A6D1-4432-9F2D-D8C4E3A8207D}</string>
								<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Terrain = workspace.Terrain

local AOTWireframeHandle: WireframeHandleAdornment = Terrain:FindFirstChild("AOTGizmoAdornment")
local WireframeHandle: WireframeHandleAdornment = Terrain:FindFirstChild("GizmoAdornment")

if not AOTWireframeHandle then
	AOTWireframeHandle = Instance.new("WireframeHandleAdornment")
	AOTWireframeHandle.Adornee = Terrain
	AOTWireframeHandle.ZIndex = 1
	AOTWireframeHandle.AlwaysOnTop = true
	AOTWireframeHandle.Name = "AOTGizmoAdornment"
	AOTWireframeHandle.Parent = Terrain
end

if not WireframeHandle then
	WireframeHandle = Instance.new("WireframeHandleAdornment")
	WireframeHandle.Adornee = Terrain
	WireframeHandle.ZIndex = 1
	WireframeHandle.AlwaysOnTop = false
	WireframeHandle.Name = "GizmoAdornment"
	WireframeHandle.Parent = Terrain
end

local Gizmos = script:WaitForChild("Gizmos")

local ActiveObjects = {}
local RetainObjects = {}
local Debris = {}
local Tweens = {}
local PropertyTable = { AlwaysOnTop = true }
local Pool = {}

local CleanerScheduled = false

local function Retain(Gizmo, GizmoProperties)
	table.insert(RetainObjects, { Gizmo, GizmoProperties })
end

local function Register(object)
	table.insert(ActiveObjects, object)
end

local function Release(object)
	local ClassName = object.ClassName

	if not Pool[ClassName] then
		Pool[ClassName] = {}
	end

	object:Remove()
	table.insert(Pool[ClassName], object)
end

local function Request(ClassName)
	if not Pool[ClassName] then
		return Instance.new(ClassName)
	elseif not Pool[ClassName][1] then
		return Instance.new(ClassName)
	end

	local Object = Pool[ClassName][1]
	table.remove(Pool[ClassName], 1)

	return Object
end

local function Lerp(a, b, t)
	return a + (b - a) * t
end

local function deepCopy(original)
	local copy = {}
	for k, v in pairs(original) do
		if type(v) == "table" then
			v = deepCopy(v)
		end
		copy[k] = v
	end
	return copy
end

-- Types

type IRay = {
	Draw: (self, Origin: Vector3, End: Vector3) -> nil,
	Create: (
		self,
		Origin: Vector3,
		End: Vector3
	) -> { Origin: Vector3, End: Vector3, Color3: Color3, AlwaysOnTop: boolean, Transparency: number },
}

type IBox = {
	Draw: (self, Transform: CFrame, Size: Vector3, DrawTriangles: boolean) -> nil,
	Create: (
		self,
		Transform: CFrame,
		Size: Vector3,
		DrawTriangles: boolean
	) -> {
		Transform: CFrame,
		Size: Vector3,
		DrawTriangles: boolean,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IWedge = {
	Draw: (self, Transform: CFrame, Size: Vector3, DrawTriangles: boolean) -> nil,
	Create: (
		self,
		Transform: CFrame,
		Size: Vector3,
		DrawTriangles: boolean
	) -> {
		Transform: CFrame,
		Size: Vector3,
		DrawTriangles: boolean,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type ICircle = {
	Draw: (self, Transform: CFrame, Radius: number, Subdivisions: number, ConnectToStart: boolean?) -> nil,
	Create: (
		self,
		Transform: CFrame,
		Radius: number,
		Subdivisions: number,
		ConnectToStart: boolean?
	) -> {
		Transform: CFrame,
		Radius: number,
		Subdivisions: number,
		ConnectToStart: boolean?,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type ISphere = {
	Draw: (self, Transform: CFrame, Radius: number, Subdivisions: number) -> nil,
	Create: (
		self,
		Transform: CFrame,
		Radius: number,
		Subdivisions: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Subdivisions: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type ICylinder = {
	Draw: (self, Transform: CFrame, Radius: number, Length: number, Subdivisions: number) -> nil,
	Create: (
		self,
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type ICapsule = {
	Draw: (self, Transform: CFrame, Radius: number, Length: number, Subdivisions: number) -> nil,
	Create: (
		self,
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type ICone = {
	Draw: (self, Transform: CFrame, Radius: number, Length: number, Subdivisions: number) -> nil,
	Create: (
		self,
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IArrow = {
	Draw: (self, Origin: Vector3, End: Vector3, Radius: number, Length: number, Subdivisions: number) -> nil,
	Create: (
		self,
		Origin: Vector3,
		End: Vector3,
		Radius: number,
		Length: number,
		Subdivisions: number
	) -> {
		Origin: Vector3,
		End: Vector3,
		Radius: number,
		Length: number,
		Subdivisions: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IMesh = {
	Draw: (self, Transform: CFrame, Size: Vector3, Vertices: {}, Faces: {}) -> nil,
	Create: (
		self,
		Transform: CFrame,
		Size: Vector3,
		Vertices: {},
		Faces: {}
	) -> {
		Transform: CFrame,
		Size: Vector3,
		Vertices: {},
		Faces: {},
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type ILine = {
	Draw: (self, Transform: CFrame, Length: number) -> nil,
	Create: (
		self,
		Transform: CFrame,
		Length: number
	) -> {
		Transform: CFrame,
		Length: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IVolumeCone = {
	Draw: (self, Transform: CFrame, Radius: number, Length: number) -> nil,
	Create: (
		self,
		Transform: CFrame,
		Radius: number,
		Length: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Length: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IVolumeBox = {
	Draw: (self, Transform: CFrame, Size: Vector3) -> nil,
	Create: (
		self,
		Transform: CFrame,
		Size: Vector3
	) -> {
		Transform: CFrame,
		Size: Vector3,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IVolumeSphere = {
	Draw: (self, Transform: CFrame, Radius: number) -> nil,
	Create: (
		self,
		Transform: CFrame,
		Radius: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IVolumeCylinder = {
	Draw: (self, Transform: CFrame, Radius: number, Length: number, InnerRadius: number?, Angle: number?) -> nil,
	Create: (
		self,
		Transform: CFrame,
		Radius: number,
		Length: number,
		InnerRadius: number?,
		Angle: number?
	) -> {
		Transform: CFrame,
		Radius: number,
		Length: number,
		InnerRadius: number?,
		Angle: number?,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IVolumeArrow = {
	Draw: (
		self,
		Origin: Vector3,
		End: Vector3,
		CylinderRadius: number,
		ConeRadius: number,
		Length: number,
		UseCylinder: boolean?
	) -> nil,
	Create: (
		self,
		Origin: Vector3,
		End: Vector3,
		CylinderRadius: number,
		ConeRadius: number,
		Length: number,
		UseCylinder: boolean?
	) -> {
		Origin: Vector3,
		End: Vector3,
		CylinderRadius: number,
		ConeRadius: number,
		Length: number,
		UseCylinder: boolean?,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type ICeive = {
	ActiveRays: number,
	ActiveInstances: number,

	PushProperty: (Property: string, Value: any?) -> nil,
	PopProperty: (Property: string) -> any?,
	AddDebrisInSeconds: (Seconds: number, Callback: () -> ()) -> (),
	AddDebrisInFrames: (Frames: number, Callback: () -> ()) -> (),
	SetEnabled: (Value: boolean) -> (),
	DoCleaning: () -> nil,
	ScheduleCleaning: () -> nil,
	TweenProperies: (Properties: {}, Goal: {}, TweenInfo: TweenInfo) -> () -> (),

	Ray: IRay,
	Line: ILine,
	Box: IBox,
	Wedge: IWedge,
	Circle: ICircle,
	Sphere: ISphere,
	Cylinder: ICylinder,
	Capsule: ICapsule,
	Cone: ICone,
	Arrow: IArrow,
	Mesh: IMesh,
	VolumeCone: IVolumeCone,
	VolumeBox: IVolumeBox,
	VolumeSphere: IVolumeSphere,
	VolumeCylinder: IVolumeCylinder,
	VolumeArrow: IVolumeArrow,
}

-- Ceive

--- @class CEIVE
--- Root class for all the gizmos.

local Ceive: ICeive = {
	Enabled = true,
	ActiveRays = 0,
	ActiveInstances = 0,

	AOTWireframeHandle = AOTWireframeHandle,
	WireframeHandle = WireframeHandle,
}

--- @within CEIVE
--- @function GetPoolSize
--- @return PoolSize number
function Ceive.GetPoolSize(): number
	local n = 0

	for _, t in Pool do
		n += #t
	end

	return n
end

--- @within CEIVE
--- @function PushProperty
--- Push Property sets the value of a property.
--- @param Property string
--- @param Value any
function Ceive.PushProperty(Property, Value)
	PropertyTable[Property] = Value

	if Property == "AlwaysOnTop" then
		return
	end

	pcall(function()
		AOTWireframeHandle[Property] = Value
		WireframeHandle[Property] = Value
	end)
end

--- @within CEIVE
--- @function PopProperty
--- Pop Property returns the property value.
--- @param Property string
--- @return any
function Ceive.PopProperty(Property): any
	if PropertyTable[Property] then
		return PropertyTable[Property]
	end

	return AOTWireframeHandle[Property]
end

--- @within CEIVE
--- @function DoCleaning
function Ceive.DoCleaning()
	AOTWireframeHandle:Clear()
	WireframeHandle:Clear()

	for _, Object in ActiveObjects do
		Release(Object)
	end

	ActiveObjects = {}

	Ceive.ActiveRays = 0
	Ceive.ActiveInstances = 0
end

--- @within CEIVE
--- @function ScheduleCleaning
function Ceive.ScheduleCleaning()
	if CleanerScheduled then
		return
	end

	CleanerScheduled = true

	task.delay(0, function()
		Ceive.DoCleaning()

		CleanerScheduled = false
	end)
end

--- @within CEIVE
--- @function AddDebrisInSeconds
--- Acts as a wrapper for your code that runs for a provided amount of seconds.
--- @param Seconds number
--- @param Callback function
function Ceive.AddDebrisInSeconds(Seconds: number, Callback)
	table.insert(Debris, { "Seconds", Seconds, os.clock(), Callback })
end

--- @within CEIVE
--- @function AddDebrisInFrames
--- Acts as a wrapper for your code that runs for a provided amount of frames.
--- @param Frames number
--- @param Callback function
function Ceive.AddDebrisInFrames(Frames: number, Callback)
	table.insert(Debris, { "Frames", Frames, 0, Callback })
end

--- @within CEIVE
--- @function TweenProperties
--- Tweens the property table to the goal with the provided TweenInfo, returns a function which can be used to cancel.
--- @param Properties table
--- @param Goal table
--- @param TweenInfo TweenInfo
--- @return Cancel function
function Ceive.TweenProperties(Properties: {}, Goal: {}, TweenInfo: TweenInfo): () -> ()
	local p_Properties = Properties
	local c_Properties = deepCopy(Properties)

	table.insert(Tweens, {
		p_Properties = p_Properties,
		Properties = c_Properties,
		Goal = Goal,
		TweenInfo = TweenInfo,
		Time = 0,
	})

	local TweenIndex = #Tweens

	return function()
		table.remove(Tweens, TweenIndex)
	end
end

--- @within CEIVE
--- @function Init
function Ceive.Init()
	RunService.RenderStepped:Connect(function(dt)
		for i, Tween in Tweens do
			Tween.Time += dt
			local Alpha = Tween.Time / Tween.TweenInfo.Time

			if Alpha > 1 then
				Alpha = 1
			end

			local function LerpProperty(Start, End, Time)
				if type(Start) == "number" then
					return Lerp(Start, End, Time)
				end

				return Start:Lerp(End, Time)
			end

			for k, v in Tween.Properties do
				if not Tween.Goal[k] then
					continue
				end

				local TweenAlpha =
					TweenService:GetValue(Alpha, Tween.TweenInfo.EasingStyle, Tween.TweenInfo.EasingDirection)
				local PropertyValue = LerpProperty(v, Tween.Goal[k], TweenAlpha)

				Tween.p_Properties[k] = PropertyValue
			end

			if Alpha == 1 then
				table.remove(Tweens, i)
			end
		end

		for i, DebrisObject in Debris do
			local DebrisType = DebrisObject[1]
			local DebrisLifetime = DebrisObject[2]
			local DebrisBirth = DebrisObject[3]
			local DebrisCallback = DebrisObject[4]

			if DebrisType == "Seconds" then
				if os.clock() - DebrisBirth > DebrisLifetime then
					table.remove(Debris, i)
					continue
				end

				DebrisCallback()

				continue
			end

			if DebrisBirth > DebrisLifetime then
				table.remove(Debris, i)
				continue
			end

			DebrisObject[2] += 1 -- Add 1 frame to the counter

			DebrisCallback()
		end

		for i, Gizmo in RetainObjects do
			local GizmoPropertys = Gizmo[2]

			if not GizmoPropertys.Enabled then
				continue
			end

			if GizmoPropertys.Destroy then
				table.remove(RetainObjects, i)
			end

			Gizmo[1]:Update(GizmoPropertys)
		end
	end)
end

--- @within CEIVE
--- @function SetEnabled
--- @param Value boolean
function Ceive.SetEnabled(Value)
	Ceive.Enabled = Value

	if Value == false then
		Ceive.DoCleaning()
	end
end

-- Load Gizmos

for _, Gizmo in Gizmos:GetChildren() do
	Ceive[Gizmo.Name] = require(Gizmo).Init(Ceive, PropertyTable, Request, Release, Retain, Register)
end

return Ceive
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039c5</UniqueId>
							</Properties>
							<Item class="Folder" referent="RBX7EF82BAC334143E0AE4F84D600249418">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">Gizmos</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039c6</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXED81446AAAF6432686B077CC495733FF">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Arrow</string>
										<string name="ScriptGuid">{9989EC6E-2F97-42C0-A0C8-A6560900A778}</string>
										<ProtectedString name="Source"><![CDATA[--- @class Arrow
--- Renders a wireframe arrow.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Arrow
--- @function Draw
--- @param Origin Vector3
--- @param End Vector3
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
function Gizmo:Draw(Origin: Vector3, End: Vector3, Radius: number, Length: number, Subdivisions: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	Ceive.Ray:Draw(Origin, End)

	local ArrowCFrame = CFrame.lookAt(End + ((Origin - End).Unit * (Length / 2)), End)
	Ceive.Cone:Draw(ArrowCFrame, Radius, Length, Subdivisions)
end

--- @within Arrow
--- @function Create
--- @param Origin Vector3
--- @param End Vector3
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
--- @return {Origin: Vector3, End: Vector3, Radius: number, Length: number, Subdivisions: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Origin: Vector3, End: Vector3, Radius: number, Length: number, Subdivisions: number)
	local PropertyTable = {
		Origin = Origin,
		End = End,
		Radius = Radius,
		Length = Length,
		Subdivisions = Subdivisions,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(
		PropertyTable.Origin,
		PropertyTable.End,
		PropertyTable.Radius,
		PropertyTable.Length,
		PropertyTable.Subdivisions
	)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039c7</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX20756A17D64F42ECA7F6FBA013191313">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Box</string>
										<string name="ScriptGuid">{B8183C89-5605-485D-A40B-BF59CF42E227}</string>
										<ProtectedString name="Source"><![CDATA[--- @class Box
--- Renders a wireframe box.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Box
--- @function Draw
--- @param Transform CFrame
--- @param Size Vector3
--- @param DrawTriangles boolean
function Gizmo:Draw(Transform: CFrame, Size: Vector3, DrawTriangles: boolean)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Position = Transform.Position
	local Uv = Transform.UpVector
	local Rv = Transform.RightVector
	local Lv = Transform.LookVector
	local sO2 = Size / 2
	local sUv = Uv * sO2
	local sRv = Rv * sO2
	local sLv = Lv * sO2

	local function CalculateYFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (lUv - lRv - lLv)
		local BottomRight = Position + (lUv + lRv - lLv)

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	local function CalculateZFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (-lUv - lRv + lLv)
		local BottomRight = Position + (-lUv + lRv + lLv)

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	local function CalculateXFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv - lLv)
		local TopRight = Position + (lUv - lRv + lLv)
		local BottomLeft = Position + (-lUv - lRv - lLv)
		local BottomRight = Position + (-lUv - lRv + lLv)

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	CalculateXFace(sUv, sRv, sLv)
	CalculateXFace(sUv, -sRv, sLv)

	CalculateYFace(sUv, sRv, sLv)
	CalculateYFace(-sUv, sRv, sLv)

	CalculateZFace(sUv, sRv, sLv)
	CalculateZFace(sUv, sRv, -sLv)
end

--- @within Box
--- @function Create
--- @param Transform CFrame
--- @param Size Vector3
--- @param DrawTriangles boolean
--- @return {Transform: CFrame, Size: Vector3, DrawTriangles: boolean, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Size: Vector3, DrawTriangles: boolean)
	local PropertyTable = {
		Transform = Transform,
		Size = Size,
		DrawTriangles = DrawTriangles,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Size, PropertyTable.DrawTriangles)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039c8</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX7E45738D93E444AD8EF63D6047121D69">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Capsule</string>
										<string name="ScriptGuid">{4D95AAE6-DDA2-4E53-9568-55F1FED8BD03}</string>
										<ProtectedString name="Source"><![CDATA[local Rad180D = math.rad(180)

--- @class Capsule
--- Renders a wireframe capsule.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Capsule
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	-- Draw top and bottom of cylinder
	local TopOfCylinder = Transform.Position + (Transform.UpVector * (Length / 2))
	local BottomOfCylinder = Transform.Position - (Transform.UpVector * (Length / 2))

	TopOfCylinder = CFrame.lookAt(TopOfCylinder, TopOfCylinder + Transform.UpVector)
	BottomOfCylinder = CFrame.lookAt(BottomOfCylinder, BottomOfCylinder - Transform.UpVector)

	-- Draw Cylinder Lines

	local AnglePerChunk = math.floor(360 / Subdivisions)

	local LastTop
	local LastBottom

	local FirstTop
	local FirstBottom

	for i = 0, 360, AnglePerChunk do
		local XMagnitude = math.sin(math.rad(i)) * Radius
		local YMagnitude = math.cos(math.rad(i)) * Radius

		local VertexOffset = (Transform.LookVector * YMagnitude) + (Transform.RightVector * XMagnitude)
		local TopVertexPosition = TopOfCylinder.Position + VertexOffset
		local BottomVertexPosition = BottomOfCylinder.Position + VertexOffset

		Ceive.Ray:Draw(TopVertexPosition, BottomVertexPosition)

		Ceive.Circle:Draw(
			CFrame.new(TopOfCylinder.Position) * Transform.Rotation * CFrame.Angles(0, math.rad(i), 0),
			Radius,
			Subdivisions / 2,
			90,
			false
		)
		Ceive.Circle:Draw(
			CFrame.new(BottomOfCylinder.Position) * Transform.Rotation * CFrame.Angles(Rad180D, math.rad(i), 0),
			Radius,
			Subdivisions / 2,
			90,
			false
		)

		if not LastTop then
			LastTop = TopVertexPosition
			LastBottom = BottomVertexPosition

			FirstTop = TopVertexPosition
			FirstBottom = BottomVertexPosition

			continue
		end

		Ceive.Ray:Draw(LastTop, TopVertexPosition)
		Ceive.Ray:Draw(LastBottom, BottomVertexPosition)

		LastTop = TopVertexPosition
		LastBottom = BottomVertexPosition
	end

	Ceive.Ray:Draw(LastTop, FirstTop)
	Ceive.Ray:Draw(LastBottom, FirstBottom)
end

--- @within Capsule
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
--- @return {Transform: CFrame, Radius: number, Length: number, Subdivisions: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		Subdivisions = Subdivisions,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length, PropertyTable.Subdivisions)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039c9</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX109854465E264AE8A8E923959EA2E0BF">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Circle</string>
										<string name="ScriptGuid">{7997ECC9-5430-446A-901F-C03EF3254802}</string>
										<ProtectedString name="Source"><![CDATA[--- @class Circle
--- Renders a wireframe Circle.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Circle
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
--- @param Subdivisions number
--- @param Angle number
--- @param ConnectToStart boolean?
function Gizmo:Draw(Transform: CFrame, Radius: number, Subdivisions: number, Angle: number, ConnectToStart: boolean?)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local AnglePerChunk = math.floor(Angle / Subdivisions)

	local PreviousVertex = nil
	local FirstVertex = nil

	local FinishingAngle = 0

	for i = 0, Angle, AnglePerChunk do
		local XMagnitude = math.sin(math.rad(i)) * Radius
		local YMagnitude = math.cos(math.rad(i)) * Radius

		local VertexPosition = Transform.Position
			+ ((Transform.UpVector * YMagnitude) + (Transform.RightVector * XMagnitude))

		if PreviousVertex == nil then
			PreviousVertex = VertexPosition
			FirstVertex = VertexPosition
			FinishingAngle = i
			continue
		end

		Ceive.Ray:Draw(PreviousVertex, VertexPosition)
		PreviousVertex = VertexPosition
		FinishingAngle = i
	end

	if FinishingAngle ~= Angle then
		local XMagnitude = math.sin(math.rad(Angle)) * Radius
		local YMagnitude = math.cos(math.rad(Angle)) * Radius

		local VertexPosition = Transform.Position
			+ ((Transform.UpVector * YMagnitude) + (Transform.RightVector * XMagnitude))

		Ceive.Ray:Draw(PreviousVertex, VertexPosition)
	end

	if ConnectToStart ~= false then
		Ceive.Ray:Draw(PreviousVertex, FirstVertex)
	end

	return PreviousVertex
end

--- @within Circle
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @param Subdivisions number
--- @param Angle number
--- @param ConnectToStart boolean?
--- @return {Transform: CFrame, Radius: number, Subdivisions: number, Angle: number, ConnectToStart: boolean?, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number, Subdivisions: number, Angle: number, ConnectToStart: boolean?)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Subdivisions = Subdivisions,
		Angle = Angle,
		ConnectToStart = ConnectToStart,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(
		PropertyTable.Transform,
		PropertyTable.Radius,
		PropertyTable.Subdivisions,
		PropertyTable.Angle,
		PropertyTable.ConnectToStart
	)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039ca</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXD73520E1897347BA825D52D7EFD11E9A">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Cone</string>
										<string name="ScriptGuid">{BD0296C4-C1EF-4FB2-BF9F-48216211128E}</string>
										<ProtectedString name="Source"><![CDATA[local Rad90D = math.rad(90)

--- @class Cone
--- Renders a wireframe cone.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Cone
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	Transform *= CFrame.Angles(-Rad90D, 0, 0)

	local TopOfCone = Transform.Position + Transform.UpVector * (Length / 2)
	local BottomOfCone = Transform.Position + -Transform.UpVector * (Length / 2)

	TopOfCone = CFrame.lookAt(TopOfCone, TopOfCone + Transform.UpVector)
	BottomOfCone = CFrame.lookAt(BottomOfCone, BottomOfCone - Transform.UpVector)

	local AnglePerChunk = math.floor(360 / Subdivisions)

	local Last
	local First

	for i = 0, 360, AnglePerChunk do
		local XMagnitude = math.sin(math.rad(i)) * Radius
		local YMagnitude = math.cos(math.rad(i)) * Radius

		local VertexOffset = (Transform.LookVector * YMagnitude) + (Transform.RightVector * XMagnitude)
		local VertexPosition = BottomOfCone.Position + VertexOffset

		if not Last then
			Last = VertexPosition
			First = VertexPosition

			Ceive.Ray:Draw(VertexPosition, TopOfCone.Position)

			continue
		end

		Ceive.Ray:Draw(VertexPosition, TopOfCone.Position)
		Ceive.Ray:Draw(Last, VertexPosition)

		Last = VertexPosition
	end

	Ceive.Ray:Draw(Last, First)
end

--- @within Cone
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
--- @return {Transform: CFrame, Radius: number, Length: number, Subdivisions: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		Subdivisions = Subdivisions,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length, PropertyTable.Subdivisions)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039cb</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXCB379F4A728C43CC8FD10637BB31B027">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Cylinder</string>
										<string name="ScriptGuid">{AEC52B64-0FFE-4D77-A3ED-994048EBA270}</string>
										<ProtectedString name="Source"><![CDATA[--- @class Cylinder
--- Renders a wireframe cylinder.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Cylinder
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	-- Draw top and bottom of cylinder
	local TopOfCylinder = Transform.Position + (Transform.UpVector * (Length / 2))
	local BottomOfCylinder = Transform.Position - (Transform.UpVector * (Length / 2))

	TopOfCylinder = CFrame.lookAt(TopOfCylinder, TopOfCylinder + Transform.UpVector)
	BottomOfCylinder = CFrame.lookAt(BottomOfCylinder, BottomOfCylinder - Transform.UpVector)

	-- Draw Cylinder Lines

	local AnglePerChunk = math.floor(360 / Subdivisions)

	local LastTop
	local LastBottom

	local FirstTop
	local FirstBottom

	for i = 0, 360, AnglePerChunk do
		local XMagnitude = math.sin(math.rad(i)) * Radius
		local YMagnitude = math.cos(math.rad(i)) * Radius

		local VertexOffset = (Transform.LookVector * YMagnitude) + (Transform.RightVector * XMagnitude)
		local TopVertexPosition = TopOfCylinder.Position + VertexOffset
		local BottomVertexPosition = BottomOfCylinder.Position + VertexOffset

		Ceive.Ray:Draw(TopVertexPosition, BottomVertexPosition)

		if not LastTop then
			LastTop = TopVertexPosition
			LastBottom = BottomVertexPosition

			FirstTop = TopVertexPosition
			FirstBottom = BottomVertexPosition

			continue
		end

		Ceive.Ray:Draw(LastTop, TopVertexPosition)
		Ceive.Ray:Draw(LastBottom, BottomVertexPosition)

		LastTop = TopVertexPosition
		LastBottom = BottomVertexPosition
	end

	Ceive.Ray:Draw(LastTop, FirstTop)
	Ceive.Ray:Draw(LastBottom, FirstBottom)
end

--- @within Cylinder
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
--- @return {Transform: CFrame, Radius: number, Length: number, Subdivisions: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		Subdivisions = Subdivisions,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length, PropertyTable.Subdivisions)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039cc</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXDD51845BEB1D48189B5D1E1514444BE9">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Sphere</string>
										<string name="ScriptGuid">{3496A189-A447-49A6-942C-95A5696E5B9C}</string>
										<ProtectedString name="Source"><![CDATA[local Rad90D = math.rad(90)

--- @class Sphere
--- Renders a wireframe sphere.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Sphere
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
--- @param Subdivisions number
--- @param Angle number
function Gizmo:Draw(Transform: CFrame, Radius: number, Subdivisions: number, Angle: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	Ceive.Circle:Draw(Transform, Radius, Subdivisions, Angle)
	Ceive.Circle:Draw(Transform * CFrame.Angles(0, Rad90D, 0), Radius, Subdivisions, Angle)
	Ceive.Circle:Draw(Transform * CFrame.Angles(Rad90D, 0, 0), Radius, Subdivisions, Angle)
end

--- @within Sphere
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @param Subdivisions number
--- @param Angle number
--- @return {Transform: CFrame, Radius: number, Subdivisions: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number, Subdivisions: number, Angle: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Subdivisions = Subdivisions,
		Angle = Angle,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Subdivisions, PropertyTable.Angle)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039d4</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX5B3847D5A4634DDDB1159FDD8B880B68">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Ray</string>
										<string name="ScriptGuid">{515755EB-C3EA-4E69-8C28-741244C4C4E2}</string>
										<ProtectedString name="Source"><![CDATA[--- @class Ray
--- Renders a line between two points.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Ray
--- @function Draw
--- @param Origin Vector3
--- @param End Vector3
function Gizmo:Draw(Origin: Vector3, End: Vector3)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	if self.Propertys.AlwaysOnTop then
		Ceive.AOTWireframeHandle:AddLine(Origin, End)
	else
		Ceive.WireframeHandle:AddLine(Origin, End)
	end

	self.Ceive.ActiveRays += 1

	self.Ceive.ScheduleCleaning()
end

--- @within Ray
--- @function Create
--- @param Origin Vector3
--- @param End Vector3
--- @return {Origin: Vector3, End: Vector3, Color3: Color3, AlwaysOnTop: boolean, Transparency: number}
function Gizmo:Create(Origin: Vector3, End: Vector3)
	local PropertyTable = {
		Origin = Origin,
		End = End,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Origin, PropertyTable.End)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039d6</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX7547AE3E851945819F6A5E6BAE8A38F4">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">VolumeBox</string>
										<string name="ScriptGuid">{11DA8A48-9A48-4B44-BFC1-0EF6DA9852FB}</string>
										<ProtectedString name="Source"><![CDATA[local Terrain = workspace.Terrain

--- @class VolumeBox
--- Renders a BoxHandleAdornment.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

--- @within VolumeBox
--- @function Draw
--- @param Transform CFrame
--- @param Size Vector3
function Gizmo:Draw(Transform: CFrame, Size: Vector3)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Box = self.Request("BoxHandleAdornment")
	Box.Color3 = self.Propertys.Color3
	Box.Transparency = self.Propertys.Transparency

	Box.CFrame = Transform
	Box.Size = Size
	Box.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Box.ZIndex = 1
	Box.Adornee = Terrain
	Box.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Box)
end

--- @within VolumeBox
--- @function Create
--- @param Transform CFrame
--- @param Size Vector3
--- @return {Transform: CFrame, Size: Vector3, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Size: Vector3)
	local PropertyTable = {
		Transform = Transform,
		Size = Size,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Size)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039d8</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX03BA267DF6B4496A97FE8C2387F93547">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">VolumeArrow</string>
										<string name="ScriptGuid">{95ED39AA-C931-4238-A78F-E1302F779ED7}</string>
										<ProtectedString name="Source"><![CDATA[--- @class VolumeArrow
--- Renders an arrow with a ConeHandleAdornment instead of a wireframe cone.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

--- @within VolumeArrow
--- @function Draw
--- @param Origin Vector3
--- @param End Vector3
--- @param CylinderRadius number
--- @param ConeRadius number
--- @param Length number
--- @param UseCylinder boolean?
function Gizmo:Draw(
	Origin: Vector3,
	End: Vector3,
	CylinderRadius: number,
	ConeRadius: number,
	Length: number,
	UseCylinder: boolean?
)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	if UseCylinder == true then
		local Direction = (End - Origin).Unit
		local CylinderCFrame = CFrame.lookAt(((Origin + End) / 2) + (-Direction * (Length / 2)), End)

		Ceive.VolumeCylinder:Draw(CylinderCFrame, CylinderRadius, (Origin - End).Magnitude)
	else
		Ceive.Ray:Draw(Origin, End)
	end

	local ArrowCFrame = CFrame.lookAt(End - (End - Origin).Unit * (Length / 2), End)
	Ceive.VolumeCone:Draw(ArrowCFrame, ConeRadius, Length)
end

--- @within VolumeArrow
--- @function Create
--- @param Origin Vector3
--- @param End Vector3
--- @param CylinderRadius number
--- @param ConeRadius number
--- @param Length number
--- @param UseCylinder boolean?
--- @return {Origin: Vector3, End: Vector3, CylinderRadius: number, ConeRadius: number, Length: number,  UseCylinder: boolean?, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(
	Origin: Vector3,
	End: Vector3,
	CylinderRadius: number,
	ConeRadius: number,
	Length: number,
	UseCylinder: boolean?
)
	local PropertyTable = {
		Origin = Origin,
		End = End,
		CylinderRadius = CylinderRadius,
		ConeRadius = ConeRadius,
		Length = Length,
		UseCylinder = UseCylinder,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(
		PropertyTable.Origin,
		PropertyTable.End,
		PropertyTable.Radius,
		PropertyTable.Length,
		PropertyTable.UseCylinder
	)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039da</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX17CA831DAC8A4F158F1A8D8509077D7E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Mesh</string>
										<string name="ScriptGuid">{70C36CC7-5839-43FE-85E5-CFA4DC2E5D6D}</string>
										<ProtectedString name="Source"><![CDATA[local function Map(n, start, stop, newStart, newStop)
	return ((n - start) / (stop - start)) * (newStop - newStart) + newStart
end

--- @class Mesh
--- Renders a wireframe mesh.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Mesh
--- @function Draw
--- @param Transform CFrame
--- @param Size Vector3
--- @param Vertices table
--- @param Faces table
function Gizmo:Draw(Transform: CFrame, Size: Vector3, Vertices, Faces)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local maxX = -math.huge
	local maxY = -math.huge
	local maxZ = -math.huge

	local minX = math.huge
	local minY = math.huge
	local minZ = math.huge

	for _, vertex in Vertices do
		maxX = math.max(maxX, vertex.x)
		maxY = math.max(maxY, vertex.y)
		maxZ = math.max(maxZ, vertex.z)

		minX = math.min(minX, vertex.x)
		minY = math.min(minY, vertex.y)
		minZ = math.min(minZ, vertex.z)
	end

	for i, vertex in Vertices do
		local vX = Map(vertex.x, minX, maxX, -0.5, 0.5)
		local vY = Map(vertex.y, minY, maxY, -0.5, 0.5)
		local vZ = Map(vertex.z, minZ, maxZ, -0.5, 0.5)

		local vertexCFrame = Transform * CFrame.new(Vector3.new(vX, vY, vZ) * Size)
		Vertices[i] = vertexCFrame
	end

	for _, face in Faces do
		if #face == 3 then
			local vCF1 = Vertices[face[1].v]
			local vCF2 = Vertices[face[2].v]
			local vCF3 = Vertices[face[3].v]

			Ceive.Ray:Draw(vCF1.Position, vCF2.Position)
			Ceive.Ray:Draw(vCF2.Position, vCF3.Position)
			Ceive.Ray:Draw(vCF3.Position, vCF1.Position)
		else
			local vCF1 = Vertices[face[1].v]
			local vCF2 = Vertices[face[2].v]
			local vCF3 = Vertices[face[3].v]
			local vCF4 = Vertices[face[4].v]

			Ceive.Ray:Draw(vCF1.Position, vCF2.Position)
			Ceive.Ray:Draw(vCF1.Position, vCF4.Position)
			Ceive.Ray:Draw(vCF4.Position, vCF2.Position)

			Ceive.Ray:Draw(vCF3.Position, vCF4.Position)
			Ceive.Ray:Draw(vCF2.Position, vCF3.Position)
		end
	end
end

--- @within Mesh
--- @function Create
--- @param Transform CFrame
--- @param Size Vector3
--- @param Vertices table
--- @param Faces table
--- @return {Transform: CFrame, Size: Vector3, Vertices: {}, Faces: {}, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Size: Vector3, Vertices, Faces)
	local PropertyTable = {
		Transform = Transform,
		Size = Size,
		Vertices = Vertices,
		Faces = Faces,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Size, PropertyTable.Vertices, PropertyTable.Faces)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039dc</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX107283575222455099DE7B1DFDB2B49D">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Line</string>
										<string name="ScriptGuid">{17E572C4-4C13-4DF0-97AB-4B7F4D470884}</string>
										<ProtectedString name="Source"><![CDATA[--- @class Line
--- Renders a line at a given CFrame.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Line
--- @function Draw
--- @param Transform CFrame
--- @param Length number
--- @return {Transform: CFrame, Length: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number}
function Gizmo:Draw(Transform: CFrame, Length: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Origin = Transform.Position + (Transform.LookVector * (-Length / 2))
	local End = Transform.Position + (Transform.LookVector * (Length / 2))

	Ceive.Ray:Draw(Origin, End)
end

--- @within Line
--- @function Create
--- @param Transform CFrame
--- @param Length number
--- @return {Transform: CFrame, Length: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number}
function Gizmo:Create(Transform: CFrame, Length: number)
	local PropertyTable = {
		Transform = Transform,
		Length = Length,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Length)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039de</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXC6E09FF68976424D8D62BEC6223F87CE">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">VolumeCylinder</string>
										<string name="ScriptGuid">{7B4A3D9A-8E8D-44C2-9FD1-A594EB545DCF}</string>
										<ProtectedString name="Source"><![CDATA[local Terrain = workspace.Terrain

--- @class VolumeCylinder
--- Renders a CylinderHandleAdornment.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

--- @within VolumeCylinder
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param InnerRadius number?
--- @param Angle number?
function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number, InnerRadius: number?, Angle: number?)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Cylinder = self.Request("CylinderHandleAdornment")
	Cylinder.Color3 = self.Propertys.Color3
	Cylinder.Transparency = self.Propertys.Transparency

	Cylinder.CFrame = Transform
	Cylinder.Height = Length
	Cylinder.Radius = Radius
	Cylinder.InnerRadius = InnerRadius or 0
	Cylinder.Angle = Angle or 360
	Cylinder.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Cylinder.ZIndex = 1
	Cylinder.Adornee = Terrain
	Cylinder.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Cylinder)
end

--- @within VolumeCylinder
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param InnerRadius number?
--- @param Angle number?
--- @return {Transform: CFrame, Radius: number, Length: number, InnerRadius: number?, Angle: number?, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number, Length: number, InnerRadius: number?, Angle: number?)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		InnerRadius = InnerRadius or 0,
		Angle = Angle or 360,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(
		PropertyTable.Transform,
		PropertyTable.Radius,
		PropertyTable.Length,
		PropertyTable.InnerRadius,
		PropertyTable.Angle
	)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039e0</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXC25AA9251B8042D0864F97D4452271F4">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Wedge</string>
										<string name="ScriptGuid">{A3631640-20A8-441E-9293-7B19D3B6D0B5}</string>
										<ProtectedString name="Source"><![CDATA[--- @class Wedge
--- Renders a wireframe wedge.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Wedge
--- @function Draw
--- @param Transform CFrame
--- @param Size Vector3
--- @param DrawTriangles boolean?
function Gizmo:Draw(Transform: CFrame, Size: Vector3, DrawTriangles: boolean)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Position = Transform.Position
	local Uv = Transform.UpVector
	local Rv = Transform.RightVector
	local Lv = Transform.LookVector
	local sO2 = Size / 2
	local sUv = Uv * sO2
	local sRv = Rv * sO2
	local sLv = Lv * sO2

	local YTopLeft
	local YTopRight

	local ZBottomLeft
	local ZBottomRight

	local function CalculateYFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (lUv - lRv - lLv)
		local BottomRight = Position + (lUv + lRv - lLv)

		YTopLeft = TopLeft
		YTopRight = TopRight

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	local function CalculateZFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (-lUv - lRv + lLv)
		local BottomRight = Position + (-lUv + lRv + lLv)

		ZBottomLeft = TopLeft
		ZBottomRight = TopRight

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	CalculateYFace(-sUv, sRv, sLv)

	CalculateZFace(sUv, sRv, -sLv)

	Ceive.Ray:Draw(YTopLeft, ZBottomLeft)
	Ceive.Ray:Draw(YTopRight, ZBottomRight)
	if DrawTriangles ~= false then
		Ceive.Ray:Draw(YTopRight, ZBottomLeft)
	end
end

--- @within Wedge
--- @function Create
--- @param Transform CFrame
--- @param Size Vector3
--- @param DrawTriangles boolean?
--- @return {Transform: CFrame, Size: Vector3, DrawTriangles: boolean, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Size: Vector3, DrawTriangles: boolean)
	local PropertyTable = {
		Transform = Transform,
		Size = Size,
		DrawTriangles = DrawTriangles,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Size, PropertyTable.DrawTriangles)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039e2</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXDD918CD9141A481CAD58B4626CA58DEC">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">VolumeSphere</string>
										<string name="ScriptGuid">{AD878C14-D6E7-412A-ACD8-3A23E035C77B}</string>
										<ProtectedString name="Source"><![CDATA[local Terrain = workspace.Terrain

--- @class VolumeSphere
--- Renders a SphereHandleAdornment.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

--- @within VolumeSphere
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
function Gizmo:Draw(Transform: CFrame, Radius: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Sphere = self.Request("SphereHandleAdornment")
	Sphere.Color3 = self.Propertys.Color3
	Sphere.Transparency = self.Propertys.Transparency

	Sphere.CFrame = Transform
	Sphere.Radius = Radius
	Sphere.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Sphere.ZIndex = 1
	Sphere.Adornee = Terrain
	Sphere.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Sphere)
end

--- @within VolumeSphere
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @return {Transform: CFrame, Radius: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039e4</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXCB22A8F69DBC43DCB31931E104768164">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">VolumeCone</string>
										<string name="ScriptGuid">{2B8B7B24-5597-470C-9181-2973FA0D3FA8}</string>
										<ProtectedString name="Source"><![CDATA[local Terrain = workspace.Terrain

--- @class VolumeCone
--- Renders a ConeHandleAdornment.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

--- @within VolumeCone
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Cone = self.Request("ConeHandleAdornment")
	Cone.Color3 = self.Propertys.Color3
	Cone.Transparency = self.Propertys.Color3

	Cone.CFrame = Transform
	Cone.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Cone.ZIndex = 1
	Cone.Height = Length
	Cone.Radius = Radius
	Cone.Adornee = Terrain
	Cone.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Cone)
end

--- @within VolumeCone
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @return {Transform: CFrame, Radius: number, Length: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number, Length: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length)
end

return Gizmo
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">68dd61fa16b5ab6004d0f444000039e6</UniqueId>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Actor" referent="RBXFCED31622C4F42219E40E16174BA782C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<token name="LevelOfDetail">0</token>
								<CoordinateFrame name="ModelMeshCFrame">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
								<Vector3 name="ModelMeshSize">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="ModelStreamingMode">0</token>
								<string name="Name">BoidActor</string>
								<bool name="NeedsPivotMigration">false</bool>
								<Ref name="PrimaryPart">null</Ref>
								<float name="ScaleFactor">1</float>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">42d80392b38072020703dde0000052fe</UniqueId>
								<OptionalCoordinateFrame name="WorldPivotData"></OptionalCoordinateFrame>
							</Properties>
							<Item class="BindableEvent" referent="RBX7C372B7C61FF4D75B04CEFAFED705EC5">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">Event</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5ce27d22ecb9388b070402df00005c12</UniqueId>
								</Properties>
							</Item>
							<Item class="Script" referent="RBX9DC16FC2BB9A4D87B7039B8BA27C897F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Disabled">true</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">BoidActorScript</string>
									<token name="RunContext">2</token>
									<string name="ScriptGuid">{BCFF0E2E-0724-40DD-8F9C-76D002D0218D}</string>
									<ProtectedString name="Source"><![CDATA[local SharedTableRegistry = game:GetService("SharedTableRegistry")
local RunService = game:GetService("RunService")

local SharedBoidTable = SharedTableRegistry:GetSharedTable("BoidTable")
local LocalBoidTable = {}

local Actor = script:GetActor()
local BoidDone = Actor.Parent.BoidDone

local BoidsToUpdate = {}

local Paused = false

local function GetAngleBetweenVectors(V1: Vector3, V2: Vector3): number
	return math.acos(V1:Dot(V2) / V1.Magnitude / V2.Magnitude)
end
local function ClampVector(Vector: Vector3, Max: number): Vector3
	if Vector.Magnitude >= Max then
		return Vector.Unit * Max
	end
	return Vector
end

local function IsBoidVisible(self, OtherBoid)
	if OtherBoid.Id == self.Id then
		return false
	end

	if (self.Position - OtherBoid.Position).Magnitude > self.Range then
		return false
	end
	if GetAngleBetweenVectors(self.Position, OtherBoid.Position) > self.ViewAngle then
		return false
	end
	return true
end
local function IsHeadingForCollision(self)
	if workspace:Spherecast(self.Position, self.ObstacleMargin, self.Velocity.Unit * self.ObstacleAvoidRadius, self.ObstacleParams) then
		return true
	end
	return false
end
local function GetFurthestUnobstructedDirection(self)
	local BestDirection = Vector3.zero
	local FurthestUnobstructedDistance = 0
	for _, Direction in self.__Directions do
		Direction = CFrame.lookAt(Vector3.zero, self.Velocity.Unit) * -Direction
		local Hit = workspace:Spherecast(self.Position, self.ObstacleMargin, Direction, self.ObstacleParams)
		if not Hit then
			BestDirection = Direction
			break
		end
		if Hit.Distance > FurthestUnobstructedDistance then
			BestDirection = Direction
			FurthestUnobstructedDistance = Hit.Distance
		end
	end
	--Gizmo.PushProperty("AlwaysOnTop", true)
	--Gizmo.Ray:Draw(self.Position, self.Position + BestDirection)
	return BestDirection
end
local function ComputeAcceleration(self): Vector3?
	local Acceleration = Vector3.zero

	local TargetHeading = if self.Target then (self.Target - self.Position)  * self.TargetWeight else Vector3.zero
	Acceleration += TargetHeading

	if self.IsObstacleAvoidanceEnabled and IsHeadingForCollision(self) then
		Acceleration += GetFurthestUnobstructedDirection(self).Unit * self.ObstacleAvoidWeight
	end

	local NumBoids = 0
	local AvoidBoids = 0

	local AverageHeading = Vector3.zero
	local AveragePosition = Vector3.zero
	local SeperationHeading = Vector3.zero
	for _, OtherBoid in LocalBoidTable do
		if OtherBoid.Id == self.Id then
			continue
		end
		if not IsBoidVisible(self, OtherBoid) then
			continue
		end
		local Offset = OtherBoid.Position - self.Position
		local Distance = Offset.Magnitude
		AverageHeading += OtherBoid.Velocity
		AveragePosition += OtherBoid.Position
		if Distance < self.AvoidRadius then
			SeperationHeading -= Offset / (Distance + 1)
			AvoidBoids += 1
		end
		NumBoids += 1
	end
	if NumBoids > 0 then
		AverageHeading /= NumBoids
		AverageHeading *= self.AlignWeight
		Acceleration += AverageHeading

		AveragePosition = AveragePosition / NumBoids - self.Position
		AveragePosition *= self.CohesiveWeight
		Acceleration += AveragePosition
	end
	if AvoidBoids > 0 then
		SeperationHeading /= AvoidBoids
		SeperationHeading *= self.SeparationWeight
		Acceleration += SeperationHeading
	end

	Acceleration = ClampVector(Acceleration, self.MaxAcceleration)
	return Acceleration
end
function ComputeVelocity(self, Acceleration, Dt)
	return ClampVector(self.Velocity + Acceleration * Dt, self.MaxSpeed)
end
local function UpdateLocalBoidTable()
	debug.profilebegin("table shit")
	for i, Boid in SharedBoidTable do
		if BoidsToUpdate[i] then
			LocalBoidTable[i] = BoidsToUpdate[i]
			continue
		end
		local LocalBoid = LocalBoidTable[i]
		if not LocalBoid then
			LocalBoid = table.create(3)
			LocalBoidTable[i] = LocalBoid
		end
		LocalBoid.Position = Boid.Position
		LocalBoid.Velocity = Boid.Velocity
		LocalBoid.Id = Boid.Id
	end
	debug.profileend()
end
RunService.Heartbeat:ConnectParallel(function(Dt)
	if Paused then return end
	UpdateLocalBoidTable()
	for _, Boid in BoidsToUpdate do
		local Acceleration = ComputeAcceleration(Boid)
		local Velocity = ComputeVelocity(Boid, Acceleration, Dt)
		local Position = Boid.Position + Velocity * Dt

		if Position ~= Position then
			Position = Vector3.zero
		end
		if Velocity ~= Velocity then
			Position = Vector3.zero
		end
		if Acceleration ~= Acceleration then
			Position = Vector3.zero
		end

		Boid.Acceleration = Acceleration
		Boid.Velocity = Velocity
		Boid.Position = Position

		SharedBoidTable[Boid.Id].Position = Position
		SharedBoidTable[Boid.Id].Velocity = Velocity
		
    	BoidDone:Fire(Boid.Id, Position, Velocity, Acceleration)
	end
end)
Actor:BindToMessage("NewBoid", function(Boid)
	BoidsToUpdate[Boid.Id] = Boid
end)
Actor:BindToMessage("DestroyBoid", function(Id)
	BoidsToUpdate[Id] = nil
end)
Actor:BindToMessage("UpdateBoid", function(Id, Property, Input)
	BoidsToUpdate[Id][Property] = Input
end)
Actor:BindToMessage("Pause", function()
	Paused = true
end)
Actor:BindToMessage("Unpause", function()
	Paused = false
end)]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">00ae176e565c4b0407052491000053a3</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="BindableEvent" referent="RBX44607C582BAA4E4ABE9074659DAF1171">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">BoidDone</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">42d80392b38072020703dde000005301</UniqueId>
							</Properties>
						</Item>
						<Item class="Actor" referent="RBXFA7A37C068384FE8A2CF23792C8DC15F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<token name="LevelOfDetail">0</token>
								<CoordinateFrame name="ModelMeshCFrame">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
								<Vector3 name="ModelMeshSize">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="ModelStreamingMode">0</token>
								<string name="Name">BoidActorServer</string>
								<bool name="NeedsPivotMigration">false</bool>
								<Ref name="PrimaryPart">null</Ref>
								<float name="ScaleFactor">1</float>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">6d774d959b01b73807051d29000079aa</UniqueId>
								<OptionalCoordinateFrame name="WorldPivotData"></OptionalCoordinateFrame>
							</Properties>
							<Item class="BindableEvent" referent="RBXCCF8C45B81EA4736AA792C4ECE70CE4C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">Event</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">6d774d959b01b73807051d29000079a9</UniqueId>
								</Properties>
							</Item>
							<Item class="Script" referent="RBX9E5ECE54F1C3438397E51BCE5624466D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Disabled">true</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">BoidActorScript</string>
									<token name="RunContext">1</token>
									<string name="ScriptGuid">{555FE2DB-93FB-425A-941A-B703083B706C}</string>
									<ProtectedString name="Source"><![CDATA[local SharedTableRegistry = game:GetService("SharedTableRegistry")
local RunService = game:GetService("RunService")

local SharedBoidTable = SharedTableRegistry:GetSharedTable("BoidTable")
local LocalBoidTable = {}

local Actor = script:GetActor()
local BoidDone = Actor.Parent.BoidDone

local BoidsToUpdate = {}

local Paused = false

local function GetAngleBetweenVectors(V1: Vector3, V2: Vector3): number
	return math.acos(V1:Dot(V2) / V1.Magnitude / V2.Magnitude)
end
local function ClampVector(Vector: Vector3, Max: number): Vector3
	if Vector.Magnitude >= Max then
		return Vector.Unit * Max
	end
	return Vector
end

local function IsBoidVisible(self, OtherBoid)
	if OtherBoid.Id == self.Id then
		return false
	end

	if (self.Position - OtherBoid.Position).Magnitude > self.Range then
		return false
	end
	if GetAngleBetweenVectors(self.Position, OtherBoid.Position) > self.ViewAngle then
		return false
	end
	return true
end
local function IsHeadingForCollision(self)
	if workspace:Spherecast(self.Position, self.ObstacleMargin, self.Velocity.Unit * self.ObstacleAvoidRadius, self.ObstacleParams) then
		return true
	end
	return false
end
local function GetFurthestUnobstructedDirection(self)
	local BestDirection = Vector3.zero
	local FurthestUnobstructedDistance = 0
	for _, Direction in self.__Directions do
		Direction = CFrame.lookAt(Vector3.zero, self.Velocity.Unit) * -Direction
		local Hit = workspace:Spherecast(self.Position, self.ObstacleMargin, Direction, self.ObstacleParams)
		if not Hit then
			BestDirection = Direction
			break
		end
		if Hit.Distance > FurthestUnobstructedDistance then
			BestDirection = Direction
			FurthestUnobstructedDistance = Hit.Distance
		end
	end
	--Gizmo.PushProperty("AlwaysOnTop", true)
	--Gizmo.Ray:Draw(self.Position, self.Position + BestDirection)
	return BestDirection
end
local function ComputeAcceleration(self): Vector3?
	local Acceleration = Vector3.zero

	local TargetHeading = if self.Target then (self.Target - self.Position)  * self.TargetWeight else Vector3.zero
	Acceleration += TargetHeading

	if self.IsObstacleAvoidanceEnabled and IsHeadingForCollision(self) then
		Acceleration += GetFurthestUnobstructedDirection(self).Unit * self.ObstacleAvoidWeight
	end

	local NumBoids = 0
	local AvoidBoids = 0

	local AverageHeading = Vector3.zero
	local AveragePosition = Vector3.zero
	local SeperationHeading = Vector3.zero
	for _, OtherBoid in LocalBoidTable do
		if OtherBoid.Id == self.Id then
			continue
		end
		if not IsBoidVisible(self, OtherBoid) then
			continue
		end
		local Offset = OtherBoid.Position - self.Position
		local Distance = Offset.Magnitude
		AverageHeading += OtherBoid.Velocity
		AveragePosition += OtherBoid.Position
		if Distance < self.AvoidRadius then
			SeperationHeading -= Offset / (Distance + 1)
			AvoidBoids += 1
		end
		NumBoids += 1
	end
	if NumBoids > 0 then
		AverageHeading /= NumBoids
		AverageHeading *= self.AlignWeight
		Acceleration += AverageHeading

		AveragePosition = AveragePosition / NumBoids - self.Position
		AveragePosition *= self.CohesiveWeight
		Acceleration += AveragePosition
	end
	if AvoidBoids > 0 then
		SeperationHeading /= AvoidBoids
		SeperationHeading *= self.SeparationWeight
		Acceleration += SeperationHeading
	end

	Acceleration = ClampVector(Acceleration, self.MaxAcceleration)
	return Acceleration
end
function ComputeVelocity(self, Acceleration, Dt)
	return ClampVector(self.Velocity + Acceleration * Dt, self.MaxSpeed)
end
local function UpdateLocalBoidTable()
	debug.profilebegin("table shit")
	for i, Boid in SharedBoidTable do
		if BoidsToUpdate[i] then
			LocalBoidTable[i] = BoidsToUpdate[i]
			continue
		end
		local LocalBoid = LocalBoidTable[i]
		if not LocalBoid then
			LocalBoid = table.create(3)
			LocalBoidTable[i] = LocalBoid
		end
		LocalBoid.Position = Boid.Position
		LocalBoid.Velocity = Boid.Velocity
		LocalBoid.Id = Boid.Id
	end
	debug.profileend()
end
RunService.Heartbeat:ConnectParallel(function(Dt)
	if Paused then return end
	UpdateLocalBoidTable()
	for _, Boid in BoidsToUpdate do
		local Acceleration = ComputeAcceleration(Boid)
		local Velocity = ComputeVelocity(Boid, Acceleration, Dt)
		local Position = Boid.Position + Velocity * Dt

		if Position ~= Position then
			Position = Vector3.zero
		end
		if Velocity ~= Velocity then
			Position = Vector3.zero
		end
		if Acceleration ~= Acceleration then
			Position = Vector3.zero
		end

		Boid.Acceleration = Acceleration
		Boid.Velocity = Velocity
		Boid.Position = Position

		SharedBoidTable[Boid.Id].Position = Position
		SharedBoidTable[Boid.Id].Velocity = Velocity
		
    	BoidDone:Fire(Boid.Id, Position, Velocity, Acceleration)
	end
end)
Actor:BindToMessage("NewBoid", function(Boid)
	BoidsToUpdate[Boid.Id] = Boid
end)
Actor:BindToMessage("DestroyBoid", function(Id)
	BoidsToUpdate[Id] = nil
end)
Actor:BindToMessage("UpdateBoid", function(Id, Property, Input)
	BoidsToUpdate[Id][Property] = Input
end)
Actor:BindToMessage("Pause", function()
	Paused = true
end)
Actor:BindToMessage("Unpause", function()
	Paused = false
end)]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">6d774d959b01b73807051d29000079ab</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXBBBE9823171E4EEDADFECD6FD86F41F7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Testing</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">6aa5ca279eda671204c67b5600003d36</UniqueId>
				</Properties>
				<Item class="Script" referent="RBX52A4139810FD4EC2A2C8BDC65430D79E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BoidTest</string>
						<token name="RunContext">2</token>
						<string name="ScriptGuid">{53AA4C50-2FAB-4499-974B-FEF267988230}</string>
						<ProtectedString name="Source"><![CDATA[--!native
local Boids = require(script.Parent.Parent.Boids)
--local BoxContainer = require(script.Parent.BoxContainer).new(Vector3.zero, Vector3.new(200, 200, 200))
local RandomGenerator = Random.new()
local BoidTemplate = Instance.new("Part")
BoidTemplate.Size = Vector3.new(1, 1, 1)
BoidTemplate.Material = Enum.Material.SmoothPlastic
BoidTemplate.CastShadow = false
BoidTemplate.CanCollide = false
BoidTemplate.CanQuery = false
BoidTemplate.Anchored = true
Boids.Pause()
for _ = 1, 300, 1 do
	local X = RandomGenerator:NextNumber(-5, 5)
	local Y = RandomGenerator:NextNumber(-5, 5)
	local Z = RandomGenerator:NextNumber(-5, 5)
	local Position = Vector3.new(X, Y, Z)
	X = RandomGenerator:NextNumber(-10, 10)
	Y = RandomGenerator:NextNumber(-10, 10)
	Z = RandomGenerator:NextNumber(-10, 10)
	local Velocity = Vector3.new(X, Y, Z)
	local Boid = Boids.new(BoidTemplate, Position, Velocity)
	--Boid.BoxContainer = BoxContainer
	--Boid:ShowAcceleration()
	--Boid:ShowVelocity()
end
task.wait(5)
Boids.Unpause()
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">00ae176e565c4b0407052491000056bd</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBX4AAFCFDD57C44D2E921AB9A2D21AFC0C">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">0d3aa7196f579588018293e80001936f</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBXD9701CCEE10D4D20A3140B61F2F24306">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e800019197</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBXDBA8865DA77E41BDA4282B83E87D7728">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="RtlTextSupport">0</token>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e800019198</UniqueId>
			<token name="VirtualCursorMode">0</token>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBXD5527AEB881E4FDFB7C2920CE26925DA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e80001919a</UniqueId>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX81DE961CCAF144EC80F7F338C4A6A7D0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e80001919e</UniqueId>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX94D9E127F4794473A3D6343538F51264">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191a0</UniqueId>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX059DA8AA14F3488D951C38961ADBD21D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191a1</UniqueId>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBX3F8A0C274EA24F1F8A0110B706CED522">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191a5</UniqueId>
		</Properties>
		<Item class="StringValue" referent="RBXF00694C685584C09979D72A2E3BB994F">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">0d3aa7196f579588018293e800019370</UniqueId>
				<string name="Value">{60FBA7A2-1BDD-4763-B297-91B06EB726D4}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBX40A1951873874C59B041DFD8FBB7EF17">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191a6</UniqueId>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBXB7B8B388DD2345B6A66F35175EFB8103">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191a7</UniqueId>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBXED72B4F021554289B6272644597DE3AA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191a8</UniqueId>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX06C60CE2D32A41FEAD2C110287F24BAE">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191bd</UniqueId>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBX6E3D7D1BA0CE46D0B806D3A56F4E3252">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AutomaticScaling">0</token>
			<bool name="AvatarGestures">false</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="ControllerModels">1</token>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="FadeOutViewOnCollision">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="LaserPointer">1</token>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191b2</UniqueId>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBX9D67025485B5498E8D1E23BCFBBF0390">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191b3</UniqueId>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBX62D303DA6A5A450AB30BD82ADA139A7F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191b5</UniqueId>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBXADD3462C442745F6A06ECE0C7AF76C4A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191b6</UniqueId>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBX08B72EEB8E024B30A84F5EE05768DB67">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191b7</UniqueId>
		</Properties>
	</Item>
	<Item class="LuaWebService" referent="RBX85C2FC6E0A394EE3BA5490856CC3D075">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191d1</UniqueId>
		</Properties>
	</Item>
	<Item class="ProcessInstancePhysicsService" referent="RBX54D58183325743BAAAC21CA18C0E598B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ProcessInstancePhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191d5</UniqueId>
		</Properties>
	</Item>
	<Item class="ReplicatedStorage" referent="1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191c8</UniqueId>
		</Properties>
		<Item class="Folder" referent="2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Common</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">0d3aa7196f579588018293e800019379</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="ServerScriptService" referent="4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191c6</UniqueId>
		</Properties>
		<Item class="Script" referent="5">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Server</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{5F94A1F4-56B2-4DD5-A0DC-F8822E97E7F6}</string>
				<ProtectedString name="Source"></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">0d3aa7196f579588018293e800019371</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="RBX024DB221A6C04577A90D05EBC0737C6A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191c7</UniqueId>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBX112EAF3E6CAC4CBFB4CD7F562A8437BD">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="HttpEnabled">false</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e80001937b</UniqueId>
		</Properties>
	</Item>
	<Item class="Lighting" referent="0">
		<Properties>
			<Color3 name="Ambient">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<BinaryString name="AttributesSerialize">AQAAACAAAABSQlhfT3JpZ2luYWxUZWNobm9sb2d5T25GaWxlTG9hZAQBAAAA</BinaryString>
			<float name="Brightness">2</float>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<bool name="DefinesCapabilities">false</bool>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="Intent">0</token>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">false</bool>
			<token name="Quality">1</token>
			<float name="ShadowSoftness">0.5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">1</token>
			<string name="TimeOfDay">14:00:00</string>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e8000191f1</UniqueId>
		</Properties>
	</Item>
	<Item class="LodDataService" referent="RBX18855EE15BE04747BF5E70C5D7E0F6C7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">24b5b5913f5c7a6d01f00d7b00019791</UniqueId>
		</Properties>
	</Item>
	<Item class="ServiceVisibilityService" referent="RBXBA4CF006420C4F6A9A59141186147DB4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<BinaryString name="HiddenServices">AAAAAA==</BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServiceVisibilityService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">1811d0edb960c15e04b683aa0000334f</UniqueId>
			<BinaryString name="VisibleServices">AAAAAA==</BinaryString>
		</Properties>
	</Item>
	<Item class="ProximityPromptService" referent="RBX0874CA47C821479680A5964F270A4953">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Enabled">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxPromptsVisible">16</int>
			<string name="Name">ProximityPromptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">0d3aa7196f579588018293e80001937c</UniqueId>
		</Properties>
	</Item>
	<Item class="Teams" referent="RBX3D2F2758934B4E0F880924161BD20191">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Teams</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">1c2a6a822be3f3c602b1b64c000af52e</UniqueId>
		</Properties>
	</Item>
	<Item class="VirtualInputManager" referent="RBX85417AA9CCBB432889A5D4E6B41D437D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VirtualInputManager</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">1811d0edb960c15e04b683aa0000338c</UniqueId>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBXFE83CF0058814A25838F7063BDAEF399">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="Is30FpsThrottleEnabled">true</bool>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
			<UniqueId name="UniqueId">028a93ce43f070f004b8ff28000034cb</UniqueId>
		</Properties>
	</Item>
	<Item class="UGCAvatarService" referent="RBX6970019EEE97459FBCBA0AF2FC02FE59">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">UGCAvatarService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">42d80392b38072020703dde0000003aa</UniqueId>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>